// Code generated by goa v3.1.1, DO NOT EDIT.
//
// ChronosAPI HTTP client types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-core/api/design -o ../

package client

import (
	chronosapi "github.com/InjectiveLabs/dexterm/gen/chronos_api"
	goa "goa.design/goa/v3/pkg"
)

// SymbolInfoResponseBody is the type of the "ChronosAPI" service "symbolInfo"
// endpoint HTTP response body.
type SymbolInfoResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
	// This is the name of the symbol - a string that the users will see. It should
	// contain uppercase letters, numbers, a dot or an underscore. Also, it will be
	// used for data requests if you are not using tickers.
	Symbol []string `form:"symbol,omitempty" json:"symbol,omitempty" xml:"symbol,omitempty"`
	// Description of a symbol. Will be displayed in the chart legend for this
	// symbol.
	Description []string `form:"description,omitempty" json:"description,omitempty" xml:"description,omitempty"`
	// Symbol currency, also named as counter currency. If a symbol is a currency
	// pair, then the currency field has to contain the second currency of this
	// pair. For example, USD is a currency for EURUSD ticker. Fiat currency must
	// meet the ISO 4217 standard. The default value is null.
	Currency []string `form:"currency,omitempty" json:"currency,omitempty" xml:"currency,omitempty"`
	// Short name of exchange where this symbol is listed.
	ExchangeListed []string `form:"exchange-listed,omitempty" json:"exchange-listed,omitempty" xml:"exchange-listed,omitempty"`
	// Short name of exchange where this symbol is traded.
	ExchangeTraded []string `form:"exchange-traded,omitempty" json:"exchange-traded,omitempty" xml:"exchange-traded,omitempty"`
	// Minimal integer price change.
	Minmovement []int `form:"minmovement,omitempty" json:"minmovement,omitempty" xml:"minmovement,omitempty"`
	// Indicates how many decimal points the price has. For example, if the price
	// has 2 decimal points (ex., 300.01), then pricescale is 100. If it has 3
	// decimals, then pricescale is 1000 etc. If the price doesn't have decimals,
	// set pricescale to 1
	Pricescale []int `form:"pricescale,omitempty" json:"pricescale,omitempty" xml:"pricescale,omitempty"`
	// Timezone of the exchange for this symbol. We expect to get the name of the
	// time zone in olsondb format.
	Timezone []string `form:"timezone,omitempty" json:"timezone,omitempty" xml:"timezone,omitempty"`
	// Symbol type (forex/stock, crypto etc.).
	Type []string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	// Bitcoin and other cryptocurrencies: the session string should be 24x7
	SessionRegular []string `form:"session-regular,omitempty" json:"session-regular,omitempty" xml:"session-regular,omitempty"`
	// For currency pairs only. This field contains the first currency of the pair.
	// For example, base currency for EURUSD ticker is EUR. Fiat currency must meet
	// the ISO 4217 standard.
	BaseCurrency []string `form:"base-currency,omitempty" json:"base-currency,omitempty" xml:"base-currency,omitempty"`
	// This is a number for complex price formatting cases.
	Minmov2 []int `form:"minmov2,omitempty" json:"minmov2,omitempty" xml:"minmov2,omitempty"`
	// Boolean showing whether this symbol wants to have complex price formatting
	// (see minmov2) or not. The default value is false.
	Fractional []bool `form:"fractional,omitempty" json:"fractional,omitempty" xml:"fractional,omitempty"`
	// Root of the features. It's required for futures symbol types only. Provide a
	// null value for other symbol types. The default value is null.
	Root []string `form:"root,omitempty" json:"root,omitempty" xml:"root,omitempty"`
	// Short description of the futures root that will be displayed in the symbol
	// search. It's required for futures only. Provide a null value for other
	// symbol types. The default value is null.
	RootDescription []string `form:"root-description,omitempty" json:"root-description,omitempty" xml:"root-description,omitempty"`
	// Boolean value showing whether the symbol includes intraday (minutes)
	// historical data.
	HasIntraday []bool `form:"has-intraday,omitempty" json:"has-intraday,omitempty" xml:"has-intraday,omitempty"`
	// Boolean showing whether the symbol includes volume data or not. The default
	// value is false.
	HasNoVolume []bool `form:"has-no-volume,omitempty" json:"has-no-volume,omitempty" xml:"has-no-volume,omitempty"`
	// Boolean value showing whether the symbol is CFD. The base instrument type is
	// set using the type field.
	IsCfd []bool `form:"is-cfd,omitempty" json:"is-cfd,omitempty" xml:"is-cfd,omitempty"`
	// This is a unique identifier for this particular symbol in your symbology. If
	// you specify this property then its value will be used for all data requests
	// for this symbol.
	Ticker []string `form:"ticker,omitempty" json:"ticker,omitempty" xml:"ticker,omitempty"`
	// The boolean value showing whether data feed has its own daily resolution
	// bars or not.
	HasDaily []bool `form:"has-daily,omitempty" json:"has-daily,omitempty" xml:"has-daily,omitempty"`
	// This is an array containing intraday resolutions (in minutes) that the data
	// feed may provide
	IntradayMultipliers []string `form:"intraday-multipliers,omitempty" json:"intraday-multipliers,omitempty" xml:"intraday-multipliers,omitempty"`
	// The boolean value showing whether data feed has its own weekly and monthly
	// resolution bars or not.
	HasWeeklyAndMonthly []bool `form:"has-weekly-and-monthly,omitempty" json:"has-weekly-and-monthly,omitempty" xml:"has-weekly-and-monthly,omitempty"`
	// The currency value of a single whole unit price change in the instrument's
	// currency. If the value is not provided it is assumed to be 1.
	Pointvalue []int `form:"pointvalue,omitempty" json:"pointvalue,omitempty" xml:"pointvalue,omitempty"`
	// Expiration of the futures in the following format: YYYYMMDD. Required for
	// futures type symbols only.
	Expiration []int `form:"expiration,omitempty" json:"expiration,omitempty" xml:"expiration,omitempty"`
	// The principle of building bars. The default value is trade.
	BarSource []string `form:"bar-source,omitempty" json:"bar-source,omitempty" xml:"bar-source,omitempty"`
	// The principle of bar alignment. The default value is none.
	BarTransform []string `form:"bar-transform,omitempty" json:"bar-transform,omitempty" xml:"bar-transform,omitempty"`
	// Is used to create the zero-volume bars in the absence of any trades
	BarFillgaps []bool `form:"bar-fillgaps,omitempty" json:"bar-fillgaps,omitempty" xml:"bar-fillgaps,omitempty"`
}

// HistoryResponseBody is the type of the "ChronosAPI" service "history"
// endpoint HTTP response body.
type HistoryResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
	// Unix time of the next bar if there is no data in the requested period
	// (optional).
	Nb *int `form:"nb,omitempty" json:"nb,omitempty" xml:"nb,omitempty"`
	// Bar time, Unix timestamp (UTC). Daily bars should only have the date part,
	// time should be 0.
	T []int `form:"t,omitempty" json:"t,omitempty" xml:"t,omitempty"`
	// Open price.
	O []float64 `form:"o,omitempty" json:"o,omitempty" xml:"o,omitempty"`
	// High price.
	H []float64 `form:"h,omitempty" json:"h,omitempty" xml:"h,omitempty"`
	// Low price.
	L []float64 `form:"l,omitempty" json:"l,omitempty" xml:"l,omitempty"`
	// Close price.
	C []float64 `form:"c,omitempty" json:"c,omitempty" xml:"c,omitempty"`
	// Volume.
	V []float64 `form:"v,omitempty" json:"v,omitempty" xml:"v,omitempty"`
}

// SymbolInfoBadRequestResponseBody is the type of the "ChronosAPI" service
// "symbolInfo" endpoint HTTP response body for the "bad_request" error.
type SymbolInfoBadRequestResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
}

// SymbolInfoNotFoundResponseBody is the type of the "ChronosAPI" service
// "symbolInfo" endpoint HTTP response body for the "not_found" error.
type SymbolInfoNotFoundResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
}

// SymbolInfoInternalResponseBody is the type of the "ChronosAPI" service
// "symbolInfo" endpoint HTTP response body for the "internal" error.
type SymbolInfoInternalResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
}

// HistoryBadRequestResponseBody is the type of the "ChronosAPI" service
// "history" endpoint HTTP response body for the "bad_request" error.
type HistoryBadRequestResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
}

// HistoryNotFoundResponseBody is the type of the "ChronosAPI" service
// "history" endpoint HTTP response body for the "not_found" error.
type HistoryNotFoundResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
}

// HistoryInternalResponseBody is the type of the "ChronosAPI" service
// "history" endpoint HTTP response body for the "internal" error.
type HistoryInternalResponseBody struct {
	// Status of the response.
	S *string `form:"s,omitempty" json:"s,omitempty" xml:"s,omitempty"`
	// Error message.
	Errmsg *string `form:"errmsg,omitempty" json:"errmsg,omitempty" xml:"errmsg,omitempty"`
}

// NewSymbolInfoTradingViewSymbolInfoResponseOK builds a "ChronosAPI" service
// "symbolInfo" endpoint result from a HTTP "OK" response.
func NewSymbolInfoTradingViewSymbolInfoResponseOK(body *SymbolInfoResponseBody) *chronosapi.TradingViewSymbolInfoResponse {
	v := &chronosapi.TradingViewSymbolInfoResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
	}
	v.Symbol = make([]string, len(body.Symbol))
	for i, val := range body.Symbol {
		v.Symbol[i] = val
	}
	v.Description = make([]string, len(body.Description))
	for i, val := range body.Description {
		v.Description[i] = val
	}
	v.Currency = make([]string, len(body.Currency))
	for i, val := range body.Currency {
		v.Currency[i] = val
	}
	v.ExchangeListed = make([]string, len(body.ExchangeListed))
	for i, val := range body.ExchangeListed {
		v.ExchangeListed[i] = val
	}
	v.ExchangeTraded = make([]string, len(body.ExchangeTraded))
	for i, val := range body.ExchangeTraded {
		v.ExchangeTraded[i] = val
	}
	v.Minmovement = make([]int, len(body.Minmovement))
	for i, val := range body.Minmovement {
		v.Minmovement[i] = val
	}
	v.Pricescale = make([]int, len(body.Pricescale))
	for i, val := range body.Pricescale {
		v.Pricescale[i] = val
	}
	v.Timezone = make([]string, len(body.Timezone))
	for i, val := range body.Timezone {
		v.Timezone[i] = val
	}
	v.Type = make([]string, len(body.Type))
	for i, val := range body.Type {
		v.Type[i] = val
	}
	v.SessionRegular = make([]string, len(body.SessionRegular))
	for i, val := range body.SessionRegular {
		v.SessionRegular[i] = val
	}
	if body.BaseCurrency != nil {
		v.BaseCurrency = make([]string, len(body.BaseCurrency))
		for i, val := range body.BaseCurrency {
			v.BaseCurrency[i] = val
		}
	}
	if body.Minmov2 != nil {
		v.Minmov2 = make([]int, len(body.Minmov2))
		for i, val := range body.Minmov2 {
			v.Minmov2[i] = val
		}
	}
	if body.Fractional != nil {
		v.Fractional = make([]bool, len(body.Fractional))
		for i, val := range body.Fractional {
			v.Fractional[i] = val
		}
	}
	if body.Root != nil {
		v.Root = make([]string, len(body.Root))
		for i, val := range body.Root {
			v.Root[i] = val
		}
	}
	if body.RootDescription != nil {
		v.RootDescription = make([]string, len(body.RootDescription))
		for i, val := range body.RootDescription {
			v.RootDescription[i] = val
		}
	}
	if body.HasIntraday != nil {
		v.HasIntraday = make([]bool, len(body.HasIntraday))
		for i, val := range body.HasIntraday {
			v.HasIntraday[i] = val
		}
	}
	if body.HasNoVolume != nil {
		v.HasNoVolume = make([]bool, len(body.HasNoVolume))
		for i, val := range body.HasNoVolume {
			v.HasNoVolume[i] = val
		}
	}
	if body.IsCfd != nil {
		v.IsCfd = make([]bool, len(body.IsCfd))
		for i, val := range body.IsCfd {
			v.IsCfd[i] = val
		}
	}
	if body.Ticker != nil {
		v.Ticker = make([]string, len(body.Ticker))
		for i, val := range body.Ticker {
			v.Ticker[i] = val
		}
	}
	if body.HasDaily != nil {
		v.HasDaily = make([]bool, len(body.HasDaily))
		for i, val := range body.HasDaily {
			v.HasDaily[i] = val
		}
	}
	if body.IntradayMultipliers != nil {
		v.IntradayMultipliers = make([]string, len(body.IntradayMultipliers))
		for i, val := range body.IntradayMultipliers {
			v.IntradayMultipliers[i] = val
		}
	}
	if body.HasWeeklyAndMonthly != nil {
		v.HasWeeklyAndMonthly = make([]bool, len(body.HasWeeklyAndMonthly))
		for i, val := range body.HasWeeklyAndMonthly {
			v.HasWeeklyAndMonthly[i] = val
		}
	}
	if body.Pointvalue != nil {
		v.Pointvalue = make([]int, len(body.Pointvalue))
		for i, val := range body.Pointvalue {
			v.Pointvalue[i] = val
		}
	}
	if body.Expiration != nil {
		v.Expiration = make([]int, len(body.Expiration))
		for i, val := range body.Expiration {
			v.Expiration[i] = val
		}
	}
	if body.BarSource != nil {
		v.BarSource = make([]string, len(body.BarSource))
		for i, val := range body.BarSource {
			v.BarSource[i] = val
		}
	}
	if body.BarTransform != nil {
		v.BarTransform = make([]string, len(body.BarTransform))
		for i, val := range body.BarTransform {
			v.BarTransform[i] = val
		}
	}
	if body.BarFillgaps != nil {
		v.BarFillgaps = make([]bool, len(body.BarFillgaps))
		for i, val := range body.BarFillgaps {
			v.BarFillgaps[i] = val
		}
	}

	return v
}

// NewSymbolInfoBadRequest builds a ChronosAPI service symbolInfo endpoint
// bad_request error.
func NewSymbolInfoBadRequest(body *SymbolInfoBadRequestResponseBody) *chronosapi.BaseChronosResponse {
	v := &chronosapi.BaseChronosResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
	}

	return v
}

// NewSymbolInfoNotFound builds a ChronosAPI service symbolInfo endpoint
// not_found error.
func NewSymbolInfoNotFound(body *SymbolInfoNotFoundResponseBody) *chronosapi.BaseChronosResponse {
	v := &chronosapi.BaseChronosResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
	}

	return v
}

// NewSymbolInfoInternal builds a ChronosAPI service symbolInfo endpoint
// internal error.
func NewSymbolInfoInternal(body *SymbolInfoInternalResponseBody) *chronosapi.BaseChronosResponse {
	v := &chronosapi.BaseChronosResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
	}

	return v
}

// NewHistoryResponseOK builds a "ChronosAPI" service "history" endpoint result
// from a HTTP "OK" response.
func NewHistoryResponseOK(body *HistoryResponseBody) *chronosapi.HistoryResponse {
	v := &chronosapi.HistoryResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
		Nb:     body.Nb,
	}
	v.T = make([]int, len(body.T))
	for i, val := range body.T {
		v.T[i] = val
	}
	v.O = make([]float64, len(body.O))
	for i, val := range body.O {
		v.O[i] = val
	}
	v.H = make([]float64, len(body.H))
	for i, val := range body.H {
		v.H[i] = val
	}
	v.L = make([]float64, len(body.L))
	for i, val := range body.L {
		v.L[i] = val
	}
	v.C = make([]float64, len(body.C))
	for i, val := range body.C {
		v.C[i] = val
	}
	v.V = make([]float64, len(body.V))
	for i, val := range body.V {
		v.V[i] = val
	}

	return v
}

// NewHistoryBadRequest builds a ChronosAPI service history endpoint
// bad_request error.
func NewHistoryBadRequest(body *HistoryBadRequestResponseBody) *chronosapi.BaseChronosResponse {
	v := &chronosapi.BaseChronosResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
	}

	return v
}

// NewHistoryNotFound builds a ChronosAPI service history endpoint not_found
// error.
func NewHistoryNotFound(body *HistoryNotFoundResponseBody) *chronosapi.BaseChronosResponse {
	v := &chronosapi.BaseChronosResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
	}

	return v
}

// NewHistoryInternal builds a ChronosAPI service history endpoint internal
// error.
func NewHistoryInternal(body *HistoryInternalResponseBody) *chronosapi.BaseChronosResponse {
	v := &chronosapi.BaseChronosResponse{
		S:      *body.S,
		Errmsg: body.Errmsg,
	}

	return v
}

// ValidateSymbolInfoResponseBody runs the validations defined on
// SymbolInfoResponseBody
func ValidateSymbolInfoResponseBody(body *SymbolInfoResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.Symbol == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("symbol", "body"))
	}
	if body.Description == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("description", "body"))
	}
	if body.Currency == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("currency", "body"))
	}
	if body.ExchangeListed == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("exchange-listed", "body"))
	}
	if body.ExchangeTraded == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("exchange-traded", "body"))
	}
	if body.Minmovement == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("minmovement", "body"))
	}
	if body.Pricescale == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("pricescale", "body"))
	}
	if body.Timezone == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timezone", "body"))
	}
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.SessionRegular == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("session-regular", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	for _, e := range body.Timezone {
		if !(e == "America/New_York" || e == "America/Los_Angeles" || e == "America/Chicago" || e == "America/Phoenix" || e == "America/Toronto" || e == "America/Vancouver" || e == "America/Argentina/Buenos_Aires" || e == "America/El_Salvador" || e == "America/Sao_Paulo" || e == "America/Bogota" || e == "Europe/Moscow" || e == "Europe/Athens" || e == "Europe/Berlin" || e == "Europe/London" || e == "Europe/Madrid" || e == "Europe/Paris" || e == "Europe/Warsaw" || e == "Australia/Sydney" || e == "Australia/Brisbane" || e == "Australia/Adelaide" || e == "Australia/ACT" || e == "Asia/Almaty" || e == "Asia/Ashkhabad" || e == "Asia/Tokyo" || e == "Asia/Taipei" || e == "Asia/Singapore" || e == "Asia/Shanghai" || e == "Asia/Seoul" || e == "Asia/Tehran" || e == "Asia/Dubai" || e == "Asia/Kolkata" || e == "Asia/Hong_Kong" || e == "Asia/Bangkok" || e == "Pacific/Auckland" || e == "Pacific/Chatham" || e == "Pacific/Fakaofo" || e == "Pacific/Honolulu" || e == "America/Mexico_City" || e == "Africa/Johannesburg" || e == "Asia/Kathmandu" || e == "US/Mountain") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.timezone[*]", e, []interface{}{"America/New_York", "America/Los_Angeles", "America/Chicago", "America/Phoenix", "America/Toronto", "America/Vancouver", "America/Argentina/Buenos_Aires", "America/El_Salvador", "America/Sao_Paulo", "America/Bogota", "Europe/Moscow", "Europe/Athens", "Europe/Berlin", "Europe/London", "Europe/Madrid", "Europe/Paris", "Europe/Warsaw", "Australia/Sydney", "Australia/Brisbane", "Australia/Adelaide", "Australia/ACT", "Asia/Almaty", "Asia/Ashkhabad", "Asia/Tokyo", "Asia/Taipei", "Asia/Singapore", "Asia/Shanghai", "Asia/Seoul", "Asia/Tehran", "Asia/Dubai", "Asia/Kolkata", "Asia/Hong_Kong", "Asia/Bangkok", "Pacific/Auckland", "Pacific/Chatham", "Pacific/Fakaofo", "Pacific/Honolulu", "America/Mexico_City", "Africa/Johannesburg", "Asia/Kathmandu", "US/Mountain"}))
		}
	}
	for _, e := range body.Type {
		if !(e == "crypto") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.type[*]", e, []interface{}{"crypto"}))
		}
	}
	for _, e := range body.SessionRegular {
		if !(e == "24x7") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.session-regular[*]", e, []interface{}{"24x7"}))
		}
	}
	for _, e := range body.BarSource {
		if !(e == "bid" || e == "ask" || e == "mid" || e == "trade") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.bar-source[*]", e, []interface{}{"bid", "ask", "mid", "trade"}))
		}
	}
	for _, e := range body.BarTransform {
		if !(e == "none" || e == "openprev" || e == "prevopen" || e == "open") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.bar-transform[*]", e, []interface{}{"none", "openprev", "prevopen", "open"}))
		}
	}
	return
}

// ValidateHistoryResponseBody runs the validations defined on
// HistoryResponseBody
func ValidateHistoryResponseBody(body *HistoryResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.T == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("t", "body"))
	}
	if body.O == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("o", "body"))
	}
	if body.H == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("h", "body"))
	}
	if body.L == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("l", "body"))
	}
	if body.C == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("c", "body"))
	}
	if body.V == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("v", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	return
}

// ValidateSymbolInfoBadRequestResponseBody runs the validations defined on
// symbolInfo_bad_request_response_body
func ValidateSymbolInfoBadRequestResponseBody(body *SymbolInfoBadRequestResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	return
}

// ValidateSymbolInfoNotFoundResponseBody runs the validations defined on
// symbolInfo_not_found_response_body
func ValidateSymbolInfoNotFoundResponseBody(body *SymbolInfoNotFoundResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	return
}

// ValidateSymbolInfoInternalResponseBody runs the validations defined on
// symbolInfo_internal_response_body
func ValidateSymbolInfoInternalResponseBody(body *SymbolInfoInternalResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	return
}

// ValidateHistoryBadRequestResponseBody runs the validations defined on
// history_bad_request_response_body
func ValidateHistoryBadRequestResponseBody(body *HistoryBadRequestResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	return
}

// ValidateHistoryNotFoundResponseBody runs the validations defined on
// history_not_found_response_body
func ValidateHistoryNotFoundResponseBody(body *HistoryNotFoundResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	return
}

// ValidateHistoryInternalResponseBody runs the validations defined on
// history_internal_response_body
func ValidateHistoryInternalResponseBody(body *HistoryInternalResponseBody) (err error) {
	if body.S == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("s", "body"))
	}
	if body.S != nil {
		if !(*body.S == "ok" || *body.S == "error" || *body.S == "no_data") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.s", *body.S, []interface{}{"ok", "error", "no_data"}))
		}
	}
	return
}
