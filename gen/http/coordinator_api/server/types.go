// Code generated by goa v3.1.1, DO NOT EDIT.
//
// CoordinatorAPI HTTP server types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-core/api/design -o ../

package server

import (
	"unicode/utf8"

	coordinatorapi "github.com/InjectiveLabs/injective-core/api/gen/coordinator_api"
	goa "goa.design/goa/v3/pkg"
)

// RequestTransactionRequestBody is the type of the "CoordinatorAPI" service
// "request_transaction" endpoint HTTP request body.
type RequestTransactionRequestBody struct {
	// Signed 0x Transaction
	SignedTransaction *SignedTransactionRequestBody `form:"signedTransaction,omitempty" json:"signedTransaction,omitempty" xml:"signedTransaction,omitempty"`
	// Address of Ethereum transaction signer that is allowed to execute this 0x
	// transaction
	TxOrigin *string `form:"txOrigin,omitempty" json:"txOrigin,omitempty" xml:"txOrigin,omitempty"`
}

// SoftCancelsRequestBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP request body.
type SoftCancelsRequestBody struct {
	// The hashes of orders to be checked whether they can be soft-cancelled
	OrderHashes []string `form:"orderHashes,omitempty" json:"orderHashes,omitempty" xml:"orderHashes,omitempty"`
}

// ConfigurationResponseBody is the type of the "CoordinatorAPI" service
// "configuration" endpoint HTTP response body.
type ConfigurationResponseBody struct {
	// Duration of validity of coordinator approval in seconds
	ExpirationDurationSeconds uint32 `form:"expirationDurationSeconds" json:"expirationDurationSeconds" xml:"expirationDurationSeconds"`
	// Duration of selective delay in milliseconds
	SelectiveDelayMs uint32 `form:"selectiveDelayMs" json:"selectiveDelayMs" xml:"selectiveDelayMs"`
	// Supported Ethereum chain IDs
	SupportedChainIds []uint32 `form:"supportedChainIds" json:"supportedChainIds" xml:"supportedChainIds"`
}

// RequestTransactionResponseBody is the type of the "CoordinatorAPI" service
// "request_transaction" endpoint HTTP response body.
type RequestTransactionResponseBody struct {
	// when the signatures will expire and no longer be valid
	ExpirationTimeSeconds *string `form:"expirationTimeSeconds,omitempty" json:"expirationTimeSeconds,omitempty" xml:"expirationTimeSeconds,omitempty"`
	// the Coordinator signatures required to submit the 0x transaction
	Signatures []string `form:"signatures,omitempty" json:"signatures,omitempty" xml:"signatures,omitempty"`
	// Information about the outstanding signatures to fill the order(s) that have
	// been soft-cancelled.
	OutstandingFillSignatures []*FillSignaturesResponseBody `form:"outstandingFillSignatures,omitempty" json:"outstandingFillSignatures,omitempty" xml:"outstandingFillSignatures,omitempty"`
	// An approval signature of the cancellation 0x transaction submitted to the
	// Coordinator (with the expiration hard-coded to 0 -- although these never
	// expire). These signatures can be used to prove that a soft-cancel was
	// granted for these order(s).
	CancellationSignatures []string `form:"cancellationSignatures,omitempty" json:"cancellationSignatures,omitempty" xml:"cancellationSignatures,omitempty"`
}

// SoftCancelsResponseBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP response body.
type SoftCancelsResponseBody struct {
	// The subset of orders that have been soft-cancelled
	OrderHashes []string `form:"orderHashes" json:"orderHashes" xml:"orderHashes"`
}

// ConfigurationValidationErrorResponseBody is the type of the "CoordinatorAPI"
// service "configuration" endpoint HTTP response body for the
// "validation_error" error.
type ConfigurationValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*CoordinatorValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// ConfigurationNotFoundResponseBody is the type of the "CoordinatorAPI"
// service "configuration" endpoint HTTP response body for the "not_found"
// error.
type ConfigurationNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ConfigurationInternalResponseBody is the type of the "CoordinatorAPI"
// service "configuration" endpoint HTTP response body for the "internal" error.
type ConfigurationInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// RequestTransactionValidationErrorResponseBody is the type of the
// "CoordinatorAPI" service "request_transaction" endpoint HTTP response body
// for the "validation_error" error.
type RequestTransactionValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*CoordinatorValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// RequestTransactionNotFoundResponseBody is the type of the "CoordinatorAPI"
// service "request_transaction" endpoint HTTP response body for the
// "not_found" error.
type RequestTransactionNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// RequestTransactionInternalResponseBody is the type of the "CoordinatorAPI"
// service "request_transaction" endpoint HTTP response body for the "internal"
// error.
type RequestTransactionInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// SoftCancelsValidationErrorResponseBody is the type of the "CoordinatorAPI"
// service "soft_cancels" endpoint HTTP response body for the
// "validation_error" error.
type SoftCancelsValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*CoordinatorValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// SoftCancelsNotFoundResponseBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP response body for the "not_found" error.
type SoftCancelsNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// SoftCancelsInternalResponseBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP response body for the "internal" error.
type SoftCancelsInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// CoordinatorValidationErrorResponseBody is used to define fields on response
// body types.
type CoordinatorValidationErrorResponseBody struct {
	// Validation error code
	Code int `form:"code" json:"code" xml:"code"`
	// Validation error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// Field name
	Field *string `form:"field,omitempty" json:"field,omitempty" xml:"field,omitempty"`
}

// FillSignaturesResponseBody is used to define fields on response body types.
type FillSignaturesResponseBody struct {
	// EIP712 hash of order (see LibOrder.getTypedDataHash)
	OrderHash string `form:"orderHash" json:"orderHash" xml:"orderHash"`
	// Array of signatures that correspond to the required signatures to execute
	// each order in the transaction
	ApprovalSignatures []string `form:"approvalSignatures" json:"approvalSignatures" xml:"approvalSignatures"`
	// Timestamp in seconds at which approval expires
	ExpirationTimeSeconds string `form:"expirationTimeSeconds" json:"expirationTimeSeconds" xml:"expirationTimeSeconds"`
	// Desired amount of takerAsset to sell
	TakerAssetFillAmount string `form:"takerAssetFillAmount" json:"takerAssetFillAmount" xml:"takerAssetFillAmount"`
}

// SignedTransactionRequestBody is used to define fields on request body types.
type SignedTransactionRequestBody struct {
	// Arbitrary number to facilitate uniqueness of the transactions's hash.
	Salt *string `form:"salt,omitempty" json:"salt,omitempty" xml:"salt,omitempty"`
	// Address of transaction signer
	SignerAddress *string `form:"signerAddress,omitempty" json:"signerAddress,omitempty" xml:"signerAddress,omitempty"`
	// The calldata that is to be executed. This must call an Exchange contract
	// method.
	Data *string `form:"data,omitempty" json:"data,omitempty" xml:"data,omitempty"`
	// Timestamp in seconds at which transaction expires.
	ExpirationTimeSeconds *string `form:"expirationTimeSeconds,omitempty" json:"expirationTimeSeconds,omitempty" xml:"expirationTimeSeconds,omitempty"`
	// gasPrice that transaction is required to be executed with.
	GasPrice *string `form:"gasPrice,omitempty" json:"gasPrice,omitempty" xml:"gasPrice,omitempty"`
	// Exchange Domain specific values.
	Domain *ExchangeDomainRequestBody `form:"domain,omitempty" json:"domain,omitempty" xml:"domain,omitempty"`
	// Signature of the 0x Transaction
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
}

// ExchangeDomainRequestBody is used to define fields on request body types.
type ExchangeDomainRequestBody struct {
	// Address of the Injective Coordinator Contract.
	VerifyingContract *string `form:"verifyingContract,omitempty" json:"verifyingContract,omitempty" xml:"verifyingContract,omitempty"`
	// Ethereum Chain ID of the transaction
	ChainID *string `form:"chainId,omitempty" json:"chainId,omitempty" xml:"chainId,omitempty"`
}

// NewConfigurationResponseBody builds the HTTP response body from the result
// of the "configuration" endpoint of the "CoordinatorAPI" service.
func NewConfigurationResponseBody(res *coordinatorapi.ConfigurationResult) *ConfigurationResponseBody {
	body := &ConfigurationResponseBody{
		ExpirationDurationSeconds: res.ExpirationDurationSeconds,
		SelectiveDelayMs:          res.SelectiveDelayMs,
	}
	if res.SupportedChainIds != nil {
		body.SupportedChainIds = make([]uint32, len(res.SupportedChainIds))
		for i, val := range res.SupportedChainIds {
			body.SupportedChainIds[i] = val
		}
	}
	return body
}

// NewRequestTransactionResponseBody builds the HTTP response body from the
// result of the "request_transaction" endpoint of the "CoordinatorAPI" service.
func NewRequestTransactionResponseBody(res *coordinatorapi.RequestTransactionResult) *RequestTransactionResponseBody {
	body := &RequestTransactionResponseBody{
		ExpirationTimeSeconds: res.ExpirationTimeSeconds,
	}
	if res.Signatures != nil {
		body.Signatures = make([]string, len(res.Signatures))
		for i, val := range res.Signatures {
			body.Signatures[i] = val
		}
	}
	if res.OutstandingFillSignatures != nil {
		body.OutstandingFillSignatures = make([]*FillSignaturesResponseBody, len(res.OutstandingFillSignatures))
		for i, val := range res.OutstandingFillSignatures {
			body.OutstandingFillSignatures[i] = marshalCoordinatorapiFillSignaturesToFillSignaturesResponseBody(val)
		}
	}
	if res.CancellationSignatures != nil {
		body.CancellationSignatures = make([]string, len(res.CancellationSignatures))
		for i, val := range res.CancellationSignatures {
			body.CancellationSignatures[i] = val
		}
	}
	return body
}

// NewSoftCancelsResponseBody builds the HTTP response body from the result of
// the "soft_cancels" endpoint of the "CoordinatorAPI" service.
func NewSoftCancelsResponseBody(res *coordinatorapi.SoftCancelsResult) *SoftCancelsResponseBody {
	body := &SoftCancelsResponseBody{}
	if res.OrderHashes != nil {
		body.OrderHashes = make([]string, len(res.OrderHashes))
		for i, val := range res.OrderHashes {
			body.OrderHashes[i] = val
		}
	}
	return body
}

// NewConfigurationValidationErrorResponseBody builds the HTTP response body
// from the result of the "configuration" endpoint of the "CoordinatorAPI"
// service.
func NewConfigurationValidationErrorResponseBody(res *coordinatorapi.CoordinatorValidationErrorResponse) *ConfigurationValidationErrorResponseBody {
	body := &ConfigurationValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*CoordinatorValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalCoordinatorapiCoordinatorValidationErrorToCoordinatorValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewConfigurationNotFoundResponseBody builds the HTTP response body from the
// result of the "configuration" endpoint of the "CoordinatorAPI" service.
func NewConfigurationNotFoundResponseBody(res *goa.ServiceError) *ConfigurationNotFoundResponseBody {
	body := &ConfigurationNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewConfigurationInternalResponseBody builds the HTTP response body from the
// result of the "configuration" endpoint of the "CoordinatorAPI" service.
func NewConfigurationInternalResponseBody(res *goa.ServiceError) *ConfigurationInternalResponseBody {
	body := &ConfigurationInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewRequestTransactionValidationErrorResponseBody builds the HTTP response
// body from the result of the "request_transaction" endpoint of the
// "CoordinatorAPI" service.
func NewRequestTransactionValidationErrorResponseBody(res *coordinatorapi.CoordinatorValidationErrorResponse) *RequestTransactionValidationErrorResponseBody {
	body := &RequestTransactionValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*CoordinatorValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalCoordinatorapiCoordinatorValidationErrorToCoordinatorValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewRequestTransactionNotFoundResponseBody builds the HTTP response body from
// the result of the "request_transaction" endpoint of the "CoordinatorAPI"
// service.
func NewRequestTransactionNotFoundResponseBody(res *goa.ServiceError) *RequestTransactionNotFoundResponseBody {
	body := &RequestTransactionNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewRequestTransactionInternalResponseBody builds the HTTP response body from
// the result of the "request_transaction" endpoint of the "CoordinatorAPI"
// service.
func NewRequestTransactionInternalResponseBody(res *goa.ServiceError) *RequestTransactionInternalResponseBody {
	body := &RequestTransactionInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewSoftCancelsValidationErrorResponseBody builds the HTTP response body from
// the result of the "soft_cancels" endpoint of the "CoordinatorAPI" service.
func NewSoftCancelsValidationErrorResponseBody(res *coordinatorapi.CoordinatorValidationErrorResponse) *SoftCancelsValidationErrorResponseBody {
	body := &SoftCancelsValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*CoordinatorValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalCoordinatorapiCoordinatorValidationErrorToCoordinatorValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewSoftCancelsNotFoundResponseBody builds the HTTP response body from the
// result of the "soft_cancels" endpoint of the "CoordinatorAPI" service.
func NewSoftCancelsNotFoundResponseBody(res *goa.ServiceError) *SoftCancelsNotFoundResponseBody {
	body := &SoftCancelsNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewSoftCancelsInternalResponseBody builds the HTTP response body from the
// result of the "soft_cancels" endpoint of the "CoordinatorAPI" service.
func NewSoftCancelsInternalResponseBody(res *goa.ServiceError) *SoftCancelsInternalResponseBody {
	body := &SoftCancelsInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewConfigurationPayload builds a CoordinatorAPI service configuration
// endpoint payload.
func NewConfigurationPayload(chainID int64) *coordinatorapi.ConfigurationPayload {
	v := &coordinatorapi.ConfigurationPayload{}
	v.ChainID = chainID

	return v
}

// NewRequestTransactionPayload builds a CoordinatorAPI service
// request_transaction endpoint payload.
func NewRequestTransactionPayload(body *RequestTransactionRequestBody) *coordinatorapi.RequestTransactionPayload {
	v := &coordinatorapi.RequestTransactionPayload{
		TxOrigin: *body.TxOrigin,
	}
	v.SignedTransaction = unmarshalSignedTransactionRequestBodyToCoordinatorapiSignedTransaction(body.SignedTransaction)

	return v
}

// NewSoftCancelsPayload builds a CoordinatorAPI service soft_cancels endpoint
// payload.
func NewSoftCancelsPayload(body *SoftCancelsRequestBody, chainID int64) *coordinatorapi.SoftCancelsPayload {
	v := &coordinatorapi.SoftCancelsPayload{}
	v.OrderHashes = make([]string, len(body.OrderHashes))
	for i, val := range body.OrderHashes {
		v.OrderHashes[i] = val
	}
	v.ChainID = chainID

	return v
}

// ValidateRequestTransactionRequestBody runs the validations defined on
// request_transaction_request_body
func ValidateRequestTransactionRequestBody(body *RequestTransactionRequestBody) (err error) {
	if body.SignedTransaction == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("signedTransaction", "body"))
	}
	if body.TxOrigin == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("txOrigin", "body"))
	}
	if body.SignedTransaction != nil {
		if err2 := ValidateSignedTransactionRequestBody(body.SignedTransaction); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.TxOrigin != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.txOrigin", *body.TxOrigin, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.TxOrigin != nil {
		if utf8.RuneCountInString(*body.TxOrigin) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txOrigin", *body.TxOrigin, utf8.RuneCountInString(*body.TxOrigin), 42, true))
		}
	}
	if body.TxOrigin != nil {
		if utf8.RuneCountInString(*body.TxOrigin) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.txOrigin", *body.TxOrigin, utf8.RuneCountInString(*body.TxOrigin), 42, false))
		}
	}
	return
}

// ValidateSoftCancelsRequestBody runs the validations defined on
// soft_cancels_request_body
func ValidateSoftCancelsRequestBody(body *SoftCancelsRequestBody) (err error) {
	if body.OrderHashes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orderHashes", "body"))
	}
	for _, e := range body.OrderHashes {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.orderHashes[*]", e, "^0x[0-9a-fA-F]{64}$"))
		if utf8.RuneCountInString(e) < 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.orderHashes[*]", e, utf8.RuneCountInString(e), 66, true))
		}
		if utf8.RuneCountInString(e) > 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.orderHashes[*]", e, utf8.RuneCountInString(e), 66, false))
		}
	}
	return
}

// ValidateSignedTransactionRequestBody runs the validations defined on
// SignedTransactionRequestBody
func ValidateSignedTransactionRequestBody(body *SignedTransactionRequestBody) (err error) {
	if body.Salt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("salt", "body"))
	}
	if body.SignerAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("signerAddress", "body"))
	}
	if body.Data == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("data", "body"))
	}
	if body.ExpirationTimeSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("expirationTimeSeconds", "body"))
	}
	if body.GasPrice == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("gasPrice", "body"))
	}
	if body.Domain == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("domain", "body"))
	}
	if body.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("signature", "body"))
	}
	if body.Salt != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.salt", *body.Salt, "^\\d+(\\.\\d+)?$"))
	}
	if body.Salt != nil {
		if utf8.RuneCountInString(*body.Salt) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.salt", *body.Salt, utf8.RuneCountInString(*body.Salt), 100, false))
		}
	}
	if body.SignerAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.signerAddress", *body.SignerAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.SignerAddress != nil {
		if utf8.RuneCountInString(*body.SignerAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.signerAddress", *body.SignerAddress, utf8.RuneCountInString(*body.SignerAddress), 42, true))
		}
	}
	if body.SignerAddress != nil {
		if utf8.RuneCountInString(*body.SignerAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.signerAddress", *body.SignerAddress, utf8.RuneCountInString(*body.SignerAddress), 42, false))
		}
	}
	if body.Data != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.data", *body.Data, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	}
	if body.ExpirationTimeSeconds != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, "^\\d+(\\.\\d+)?$"))
	}
	if body.ExpirationTimeSeconds != nil {
		if utf8.RuneCountInString(*body.ExpirationTimeSeconds) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, utf8.RuneCountInString(*body.ExpirationTimeSeconds), 100, false))
		}
	}
	if body.GasPrice != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.gasPrice", *body.GasPrice, "^\\d+(\\.\\d+)?$"))
	}
	if body.GasPrice != nil {
		if utf8.RuneCountInString(*body.GasPrice) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.gasPrice", *body.GasPrice, utf8.RuneCountInString(*body.GasPrice), 100, false))
		}
	}
	if body.Domain != nil {
		if err2 := ValidateExchangeDomainRequestBody(body.Domain); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	if body.Signature != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.signature", *body.Signature, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	}
	return
}

// ValidateExchangeDomainRequestBody runs the validations defined on
// ExchangeDomainRequestBody
func ValidateExchangeDomainRequestBody(body *ExchangeDomainRequestBody) (err error) {
	if body.VerifyingContract == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("verifyingContract", "body"))
	}
	if body.ChainID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chainId", "body"))
	}
	if body.VerifyingContract != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.verifyingContract", *body.VerifyingContract, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.VerifyingContract != nil {
		if utf8.RuneCountInString(*body.VerifyingContract) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.verifyingContract", *body.VerifyingContract, utf8.RuneCountInString(*body.VerifyingContract), 42, true))
		}
	}
	if body.VerifyingContract != nil {
		if utf8.RuneCountInString(*body.VerifyingContract) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.verifyingContract", *body.VerifyingContract, utf8.RuneCountInString(*body.VerifyingContract), 42, false))
		}
	}
	if body.ChainID != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.chainId", *body.ChainID, "^\\d+(\\.\\d+)?$"))
	}
	if body.ChainID != nil {
		if utf8.RuneCountInString(*body.ChainID) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.chainId", *body.ChainID, utf8.RuneCountInString(*body.ChainID), 100, false))
		}
	}
	return
}
