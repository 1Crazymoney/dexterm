// Code generated by goa v3.1.1, DO NOT EDIT.
//
// CoordinatorAPI HTTP client types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-core/api/design -o ../

package client

import (
	"unicode/utf8"

	coordinatorapi "github.com/InjectiveLabs/injective-core/api/gen/coordinator_api"
	goa "goa.design/goa/v3/pkg"
)

// RequestTransactionRequestBody is the type of the "CoordinatorAPI" service
// "request_transaction" endpoint HTTP request body.
type RequestTransactionRequestBody struct {
	// Signed 0x Transaction
	SignedTransaction *SignedTransactionRequestBody `form:"signedTransaction" json:"signedTransaction" xml:"signedTransaction"`
	// Address of Ethereum transaction signer that is allowed to execute this 0x
	// transaction
	TxOrigin string `form:"txOrigin" json:"txOrigin" xml:"txOrigin"`
}

// SoftCancelsRequestBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP request body.
type SoftCancelsRequestBody struct {
	// The hashes of orders to be checked whether they can be soft-cancelled
	OrderHashes []string `form:"orderHashes" json:"orderHashes" xml:"orderHashes"`
}

// ConfigurationResponseBody is the type of the "CoordinatorAPI" service
// "configuration" endpoint HTTP response body.
type ConfigurationResponseBody struct {
	// Duration of validity of coordinator approval in seconds
	ExpirationDurationSeconds *uint32 `form:"expirationDurationSeconds,omitempty" json:"expirationDurationSeconds,omitempty" xml:"expirationDurationSeconds,omitempty"`
	// Duration of selective delay in milliseconds
	SelectiveDelayMs *uint32 `form:"selectiveDelayMs,omitempty" json:"selectiveDelayMs,omitempty" xml:"selectiveDelayMs,omitempty"`
	// Supported Ethereum chain IDs
	SupportedChainIds []uint32 `form:"supportedChainIds,omitempty" json:"supportedChainIds,omitempty" xml:"supportedChainIds,omitempty"`
}

// RequestTransactionResponseBody is the type of the "CoordinatorAPI" service
// "request_transaction" endpoint HTTP response body.
type RequestTransactionResponseBody struct {
	// when the signatures will expire and no longer be valid
	ExpirationTimeSeconds *string `form:"expirationTimeSeconds,omitempty" json:"expirationTimeSeconds,omitempty" xml:"expirationTimeSeconds,omitempty"`
	// the Coordinator signatures required to submit the 0x transaction
	Signatures []string `form:"signatures,omitempty" json:"signatures,omitempty" xml:"signatures,omitempty"`
	// Information about the outstanding signatures to fill the order(s) that have
	// been soft-cancelled.
	OutstandingFillSignatures []*FillSignaturesResponseBody `form:"outstandingFillSignatures,omitempty" json:"outstandingFillSignatures,omitempty" xml:"outstandingFillSignatures,omitempty"`
	// An approval signature of the cancellation 0x transaction submitted to the
	// Coordinator (with the expiration hard-coded to 0 -- although these never
	// expire). These signatures can be used to prove that a soft-cancel was
	// granted for these order(s).
	CancellationSignatures []string `form:"cancellationSignatures,omitempty" json:"cancellationSignatures,omitempty" xml:"cancellationSignatures,omitempty"`
}

// SoftCancelsResponseBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP response body.
type SoftCancelsResponseBody struct {
	// The subset of orders that have been soft-cancelled
	OrderHashes []string `form:"orderHashes,omitempty" json:"orderHashes,omitempty" xml:"orderHashes,omitempty"`
}

// ConfigurationValidationErrorResponseBody is the type of the "CoordinatorAPI"
// service "configuration" endpoint HTTP response body for the
// "validation_error" error.
type ConfigurationValidationErrorResponseBody struct {
	// General error code
	Code *int `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Error reason description
	Reason *string `form:"reason,omitempty" json:"reason,omitempty" xml:"reason,omitempty"`
	// A list of explained validation errors.
	ValidationErrors []*CoordinatorValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// ConfigurationNotFoundResponseBody is the type of the "CoordinatorAPI"
// service "configuration" endpoint HTTP response body for the "not_found"
// error.
type ConfigurationNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// ConfigurationInternalResponseBody is the type of the "CoordinatorAPI"
// service "configuration" endpoint HTTP response body for the "internal" error.
type ConfigurationInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RequestTransactionValidationErrorResponseBody is the type of the
// "CoordinatorAPI" service "request_transaction" endpoint HTTP response body
// for the "validation_error" error.
type RequestTransactionValidationErrorResponseBody struct {
	// General error code
	Code *int `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Error reason description
	Reason *string `form:"reason,omitempty" json:"reason,omitempty" xml:"reason,omitempty"`
	// A list of explained validation errors.
	ValidationErrors []*CoordinatorValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// RequestTransactionNotFoundResponseBody is the type of the "CoordinatorAPI"
// service "request_transaction" endpoint HTTP response body for the
// "not_found" error.
type RequestTransactionNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// RequestTransactionInternalResponseBody is the type of the "CoordinatorAPI"
// service "request_transaction" endpoint HTTP response body for the "internal"
// error.
type RequestTransactionInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// SoftCancelsValidationErrorResponseBody is the type of the "CoordinatorAPI"
// service "soft_cancels" endpoint HTTP response body for the
// "validation_error" error.
type SoftCancelsValidationErrorResponseBody struct {
	// General error code
	Code *int `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Error reason description
	Reason *string `form:"reason,omitempty" json:"reason,omitempty" xml:"reason,omitempty"`
	// A list of explained validation errors.
	ValidationErrors []*CoordinatorValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// SoftCancelsNotFoundResponseBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP response body for the "not_found" error.
type SoftCancelsNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// SoftCancelsInternalResponseBody is the type of the "CoordinatorAPI" service
// "soft_cancels" endpoint HTTP response body for the "internal" error.
type SoftCancelsInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name *string `form:"name,omitempty" json:"name,omitempty" xml:"name,omitempty"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID *string `form:"id,omitempty" json:"id,omitempty" xml:"id,omitempty"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message *string `form:"message,omitempty" json:"message,omitempty" xml:"message,omitempty"`
	// Is the error temporary?
	Temporary *bool `form:"temporary,omitempty" json:"temporary,omitempty" xml:"temporary,omitempty"`
	// Is the error a timeout?
	Timeout *bool `form:"timeout,omitempty" json:"timeout,omitempty" xml:"timeout,omitempty"`
	// Is the error a server-side fault?
	Fault *bool `form:"fault,omitempty" json:"fault,omitempty" xml:"fault,omitempty"`
}

// CoordinatorValidationErrorResponseBody is used to define fields on response
// body types.
type CoordinatorValidationErrorResponseBody struct {
	// Validation error code
	Code *int `form:"code,omitempty" json:"code,omitempty" xml:"code,omitempty"`
	// Validation error reason description
	Reason *string `form:"reason,omitempty" json:"reason,omitempty" xml:"reason,omitempty"`
	// Field name
	Field *string `form:"field,omitempty" json:"field,omitempty" xml:"field,omitempty"`
}

// SignedTransactionRequestBody is used to define fields on request body types.
type SignedTransactionRequestBody struct {
	// Arbitrary number to facilitate uniqueness of the transactions's hash.
	Salt string `form:"salt" json:"salt" xml:"salt"`
	// Address of transaction signer
	SignerAddress string `form:"signerAddress" json:"signerAddress" xml:"signerAddress"`
	// The calldata that is to be executed. This must call an Exchange contract
	// method.
	Data string `form:"data" json:"data" xml:"data"`
	// Timestamp in seconds at which transaction expires.
	ExpirationTimeSeconds string `form:"expirationTimeSeconds" json:"expirationTimeSeconds" xml:"expirationTimeSeconds"`
	// gasPrice that transaction is required to be executed with.
	GasPrice string `form:"gasPrice" json:"gasPrice" xml:"gasPrice"`
	// Exchange Domain specific values.
	Domain *ExchangeDomainRequestBody `form:"domain" json:"domain" xml:"domain"`
	// Signature of the 0x Transaction
	Signature string `form:"signature" json:"signature" xml:"signature"`
}

// ExchangeDomainRequestBody is used to define fields on request body types.
type ExchangeDomainRequestBody struct {
	// Address of the Injective Coordinator Contract.
	VerifyingContract string `form:"verifyingContract" json:"verifyingContract" xml:"verifyingContract"`
	// Ethereum Chain ID of the transaction
	ChainID string `form:"chainId" json:"chainId" xml:"chainId"`
}

// FillSignaturesResponseBody is used to define fields on response body types.
type FillSignaturesResponseBody struct {
	// EIP712 hash of order (see LibOrder.getTypedDataHash)
	OrderHash *string `form:"orderHash,omitempty" json:"orderHash,omitempty" xml:"orderHash,omitempty"`
	// Array of signatures that correspond to the required signatures to execute
	// each order in the transaction
	ApprovalSignatures []string `form:"approvalSignatures,omitempty" json:"approvalSignatures,omitempty" xml:"approvalSignatures,omitempty"`
	// Timestamp in seconds at which approval expires
	ExpirationTimeSeconds *string `form:"expirationTimeSeconds,omitempty" json:"expirationTimeSeconds,omitempty" xml:"expirationTimeSeconds,omitempty"`
	// Desired amount of takerAsset to sell
	TakerAssetFillAmount *string `form:"takerAssetFillAmount,omitempty" json:"takerAssetFillAmount,omitempty" xml:"takerAssetFillAmount,omitempty"`
}

// NewRequestTransactionRequestBody builds the HTTP request body from the
// payload of the "request_transaction" endpoint of the "CoordinatorAPI"
// service.
func NewRequestTransactionRequestBody(p *coordinatorapi.RequestTransactionPayload) *RequestTransactionRequestBody {
	body := &RequestTransactionRequestBody{
		TxOrigin: p.TxOrigin,
	}
	if p.SignedTransaction != nil {
		body.SignedTransaction = marshalCoordinatorapiSignedTransactionToSignedTransactionRequestBody(p.SignedTransaction)
	}
	return body
}

// NewSoftCancelsRequestBody builds the HTTP request body from the payload of
// the "soft_cancels" endpoint of the "CoordinatorAPI" service.
func NewSoftCancelsRequestBody(p *coordinatorapi.SoftCancelsPayload) *SoftCancelsRequestBody {
	body := &SoftCancelsRequestBody{}
	if p.OrderHashes != nil {
		body.OrderHashes = make([]string, len(p.OrderHashes))
		for i, val := range p.OrderHashes {
			body.OrderHashes[i] = val
		}
	}
	return body
}

// NewConfigurationResultOK builds a "CoordinatorAPI" service "configuration"
// endpoint result from a HTTP "OK" response.
func NewConfigurationResultOK(body *ConfigurationResponseBody) *coordinatorapi.ConfigurationResult {
	v := &coordinatorapi.ConfigurationResult{
		ExpirationDurationSeconds: *body.ExpirationDurationSeconds,
		SelectiveDelayMs:          *body.SelectiveDelayMs,
	}
	v.SupportedChainIds = make([]uint32, len(body.SupportedChainIds))
	for i, val := range body.SupportedChainIds {
		v.SupportedChainIds[i] = val
	}

	return v
}

// NewConfigurationValidationError builds a CoordinatorAPI service
// configuration endpoint validation_error error.
func NewConfigurationValidationError(body *ConfigurationValidationErrorResponseBody) *coordinatorapi.CoordinatorValidationErrorResponse {
	v := &coordinatorapi.CoordinatorValidationErrorResponse{
		Code:   *body.Code,
		Reason: *body.Reason,
	}
	if body.ValidationErrors != nil {
		v.ValidationErrors = make([]*coordinatorapi.CoordinatorValidationError, len(body.ValidationErrors))
		for i, val := range body.ValidationErrors {
			v.ValidationErrors[i] = unmarshalCoordinatorValidationErrorResponseBodyToCoordinatorapiCoordinatorValidationError(val)
		}
	}

	return v
}

// NewConfigurationNotFound builds a CoordinatorAPI service configuration
// endpoint not_found error.
func NewConfigurationNotFound(body *ConfigurationNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewConfigurationInternal builds a CoordinatorAPI service configuration
// endpoint internal error.
func NewConfigurationInternal(body *ConfigurationInternalResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRequestTransactionResultOK builds a "CoordinatorAPI" service
// "request_transaction" endpoint result from a HTTP "OK" response.
func NewRequestTransactionResultOK(body *RequestTransactionResponseBody) *coordinatorapi.RequestTransactionResult {
	v := &coordinatorapi.RequestTransactionResult{
		ExpirationTimeSeconds: body.ExpirationTimeSeconds,
	}
	if body.Signatures != nil {
		v.Signatures = make([]string, len(body.Signatures))
		for i, val := range body.Signatures {
			v.Signatures[i] = val
		}
	}
	if body.OutstandingFillSignatures != nil {
		v.OutstandingFillSignatures = make([]*coordinatorapi.FillSignatures, len(body.OutstandingFillSignatures))
		for i, val := range body.OutstandingFillSignatures {
			v.OutstandingFillSignatures[i] = unmarshalFillSignaturesResponseBodyToCoordinatorapiFillSignatures(val)
		}
	}
	if body.CancellationSignatures != nil {
		v.CancellationSignatures = make([]string, len(body.CancellationSignatures))
		for i, val := range body.CancellationSignatures {
			v.CancellationSignatures[i] = val
		}
	}

	return v
}

// NewRequestTransactionValidationError builds a CoordinatorAPI service
// request_transaction endpoint validation_error error.
func NewRequestTransactionValidationError(body *RequestTransactionValidationErrorResponseBody) *coordinatorapi.CoordinatorValidationErrorResponse {
	v := &coordinatorapi.CoordinatorValidationErrorResponse{
		Code:   *body.Code,
		Reason: *body.Reason,
	}
	if body.ValidationErrors != nil {
		v.ValidationErrors = make([]*coordinatorapi.CoordinatorValidationError, len(body.ValidationErrors))
		for i, val := range body.ValidationErrors {
			v.ValidationErrors[i] = unmarshalCoordinatorValidationErrorResponseBodyToCoordinatorapiCoordinatorValidationError(val)
		}
	}

	return v
}

// NewRequestTransactionNotFound builds a CoordinatorAPI service
// request_transaction endpoint not_found error.
func NewRequestTransactionNotFound(body *RequestTransactionNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewRequestTransactionInternal builds a CoordinatorAPI service
// request_transaction endpoint internal error.
func NewRequestTransactionInternal(body *RequestTransactionInternalResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewSoftCancelsResultOK builds a "CoordinatorAPI" service "soft_cancels"
// endpoint result from a HTTP "OK" response.
func NewSoftCancelsResultOK(body *SoftCancelsResponseBody) *coordinatorapi.SoftCancelsResult {
	v := &coordinatorapi.SoftCancelsResult{}
	v.OrderHashes = make([]string, len(body.OrderHashes))
	for i, val := range body.OrderHashes {
		v.OrderHashes[i] = val
	}

	return v
}

// NewSoftCancelsValidationError builds a CoordinatorAPI service soft_cancels
// endpoint validation_error error.
func NewSoftCancelsValidationError(body *SoftCancelsValidationErrorResponseBody) *coordinatorapi.CoordinatorValidationErrorResponse {
	v := &coordinatorapi.CoordinatorValidationErrorResponse{
		Code:   *body.Code,
		Reason: *body.Reason,
	}
	if body.ValidationErrors != nil {
		v.ValidationErrors = make([]*coordinatorapi.CoordinatorValidationError, len(body.ValidationErrors))
		for i, val := range body.ValidationErrors {
			v.ValidationErrors[i] = unmarshalCoordinatorValidationErrorResponseBodyToCoordinatorapiCoordinatorValidationError(val)
		}
	}

	return v
}

// NewSoftCancelsNotFound builds a CoordinatorAPI service soft_cancels endpoint
// not_found error.
func NewSoftCancelsNotFound(body *SoftCancelsNotFoundResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// NewSoftCancelsInternal builds a CoordinatorAPI service soft_cancels endpoint
// internal error.
func NewSoftCancelsInternal(body *SoftCancelsInternalResponseBody) *goa.ServiceError {
	v := &goa.ServiceError{
		Name:      *body.Name,
		ID:        *body.ID,
		Message:   *body.Message,
		Temporary: *body.Temporary,
		Timeout:   *body.Timeout,
		Fault:     *body.Fault,
	}

	return v
}

// ValidateConfigurationResponseBody runs the validations defined on
// ConfigurationResponseBody
func ValidateConfigurationResponseBody(body *ConfigurationResponseBody) (err error) {
	if body.ExpirationDurationSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("expirationDurationSeconds", "body"))
	}
	if body.SelectiveDelayMs == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("selectiveDelayMs", "body"))
	}
	if body.SupportedChainIds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("supportedChainIds", "body"))
	}
	return
}

// ValidateRequestTransactionResponseBody runs the validations defined on
// request_transaction_response_body
func ValidateRequestTransactionResponseBody(body *RequestTransactionResponseBody) (err error) {
	if body.ExpirationTimeSeconds != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, "^\\d+(\\.\\d+)?$"))
	}
	if body.ExpirationTimeSeconds != nil {
		if utf8.RuneCountInString(*body.ExpirationTimeSeconds) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, utf8.RuneCountInString(*body.ExpirationTimeSeconds), 100, false))
		}
	}
	for _, e := range body.Signatures {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.signatures[*]", e, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	}
	for _, e := range body.OutstandingFillSignatures {
		if e != nil {
			if err2 := ValidateFillSignaturesResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	for _, e := range body.CancellationSignatures {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.cancellationSignatures[*]", e, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	}
	return
}

// ValidateSoftCancelsResponseBody runs the validations defined on
// soft_cancels_response_body
func ValidateSoftCancelsResponseBody(body *SoftCancelsResponseBody) (err error) {
	if body.OrderHashes == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orderHashes", "body"))
	}
	for _, e := range body.OrderHashes {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.orderHashes[*]", e, "^0x[0-9a-fA-F]{64}$"))
		if utf8.RuneCountInString(e) < 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.orderHashes[*]", e, utf8.RuneCountInString(e), 66, true))
		}
		if utf8.RuneCountInString(e) > 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.orderHashes[*]", e, utf8.RuneCountInString(e), 66, false))
		}
	}
	return
}

// ValidateConfigurationValidationErrorResponseBody runs the validations
// defined on configuration_validation_error_response_body
func ValidateConfigurationValidationErrorResponseBody(body *ConfigurationValidationErrorResponseBody) (err error) {
	if body.Code == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("code", "body"))
	}
	if body.Reason == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("reason", "body"))
	}
	if body.Code != nil {
		if !(*body.Code == 100 || *body.Code == 101 || *body.Code == 102) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.code", *body.Code, []interface{}{100, 101, 102}))
		}
	}
	if body.Reason != nil {
		if !(*body.Reason == "Validation Failed" || *body.Reason == "Malformed JSON" || *body.Reason == "Request blocked") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.reason", *body.Reason, []interface{}{"Validation Failed", "Malformed JSON", "Request blocked"}))
		}
	}
	for _, e := range body.ValidationErrors {
		if e != nil {
			if err2 := ValidateCoordinatorValidationErrorResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateConfigurationNotFoundResponseBody runs the validations defined on
// configuration_not_found_response_body
func ValidateConfigurationNotFoundResponseBody(body *ConfigurationNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateConfigurationInternalResponseBody runs the validations defined on
// configuration_internal_response_body
func ValidateConfigurationInternalResponseBody(body *ConfigurationInternalResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRequestTransactionValidationErrorResponseBody runs the validations
// defined on request_transaction_validation_error_response_body
func ValidateRequestTransactionValidationErrorResponseBody(body *RequestTransactionValidationErrorResponseBody) (err error) {
	if body.Code == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("code", "body"))
	}
	if body.Reason == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("reason", "body"))
	}
	if body.Code != nil {
		if !(*body.Code == 100 || *body.Code == 101 || *body.Code == 102) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.code", *body.Code, []interface{}{100, 101, 102}))
		}
	}
	if body.Reason != nil {
		if !(*body.Reason == "Validation Failed" || *body.Reason == "Malformed JSON" || *body.Reason == "Request blocked") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.reason", *body.Reason, []interface{}{"Validation Failed", "Malformed JSON", "Request blocked"}))
		}
	}
	for _, e := range body.ValidationErrors {
		if e != nil {
			if err2 := ValidateCoordinatorValidationErrorResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateRequestTransactionNotFoundResponseBody runs the validations defined
// on request_transaction_not_found_response_body
func ValidateRequestTransactionNotFoundResponseBody(body *RequestTransactionNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateRequestTransactionInternalResponseBody runs the validations defined
// on request_transaction_internal_response_body
func ValidateRequestTransactionInternalResponseBody(body *RequestTransactionInternalResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateSoftCancelsValidationErrorResponseBody runs the validations defined
// on soft_cancels_validation_error_response_body
func ValidateSoftCancelsValidationErrorResponseBody(body *SoftCancelsValidationErrorResponseBody) (err error) {
	if body.Code == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("code", "body"))
	}
	if body.Reason == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("reason", "body"))
	}
	if body.Code != nil {
		if !(*body.Code == 100 || *body.Code == 101 || *body.Code == 102) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.code", *body.Code, []interface{}{100, 101, 102}))
		}
	}
	if body.Reason != nil {
		if !(*body.Reason == "Validation Failed" || *body.Reason == "Malformed JSON" || *body.Reason == "Request blocked") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.reason", *body.Reason, []interface{}{"Validation Failed", "Malformed JSON", "Request blocked"}))
		}
	}
	for _, e := range body.ValidationErrors {
		if e != nil {
			if err2 := ValidateCoordinatorValidationErrorResponseBody(e); err2 != nil {
				err = goa.MergeErrors(err, err2)
			}
		}
	}
	return
}

// ValidateSoftCancelsNotFoundResponseBody runs the validations defined on
// soft_cancels_not_found_response_body
func ValidateSoftCancelsNotFoundResponseBody(body *SoftCancelsNotFoundResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateSoftCancelsInternalResponseBody runs the validations defined on
// soft_cancels_internal_response_body
func ValidateSoftCancelsInternalResponseBody(body *SoftCancelsInternalResponseBody) (err error) {
	if body.Name == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("name", "body"))
	}
	if body.ID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("id", "body"))
	}
	if body.Message == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("message", "body"))
	}
	if body.Temporary == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("temporary", "body"))
	}
	if body.Timeout == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("timeout", "body"))
	}
	if body.Fault == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("fault", "body"))
	}
	return
}

// ValidateCoordinatorValidationErrorResponseBody runs the validations defined
// on CoordinatorValidationErrorResponseBody
func ValidateCoordinatorValidationErrorResponseBody(body *CoordinatorValidationErrorResponseBody) (err error) {
	if body.Code == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("code", "body"))
	}
	if body.Reason == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("reason", "body"))
	}
	if body.Code != nil {
		if !(*body.Code == 1000 || *body.Code == 1001 || *body.Code == 1002 || *body.Code == 1003 || *body.Code == 1004 || *body.Code == 1005 || *body.Code == 1006 || *body.Code == 1007 || *body.Code == 1008 || *body.Code == 1009 || *body.Code == 1010 || *body.Code == 1011 || *body.Code == 1012) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.code", *body.Code, []interface{}{1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012}))
		}
	}
	if body.Reason != nil {
		if !(*body.Reason == "Required field" || *body.Reason == "Incorrect format" || *body.Reason == "Value out of range" || *body.Reason == "Unsupported option" || *body.Reason == "Included order already soft-cancelled" || *body.Reason == "0x transaction decoding failed" || *body.Reason == "No Coordinator orders included" || *body.Reason == "Invalid 0x transaction signature" || *body.Reason == "Only maker can cancel orders" || *body.Reason == "Function call unsupported" || *body.Reason == "Fill requests exceeded takerAssetAmount" || *body.Reason == "0x transaction already used" || *body.Reason == "0x transaction expiration time too high") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.reason", *body.Reason, []interface{}{"Required field", "Incorrect format", "Value out of range", "Unsupported option", "Included order already soft-cancelled", "0x transaction decoding failed", "No Coordinator orders included", "Invalid 0x transaction signature", "Only maker can cancel orders", "Function call unsupported", "Fill requests exceeded takerAssetAmount", "0x transaction already used", "0x transaction expiration time too high"}))
		}
	}
	return
}

// ValidateSignedTransactionRequestBody runs the validations defined on
// SignedTransactionRequestBody
func ValidateSignedTransactionRequestBody(body *SignedTransactionRequestBody) (err error) {
	if body.Domain == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("domain", "body"))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.salt", body.Salt, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(body.Salt) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.salt", body.Salt, utf8.RuneCountInString(body.Salt), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.signerAddress", body.SignerAddress, "^0x[0-9a-fA-F]{40}$"))
	if utf8.RuneCountInString(body.SignerAddress) < 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.signerAddress", body.SignerAddress, utf8.RuneCountInString(body.SignerAddress), 42, true))
	}
	if utf8.RuneCountInString(body.SignerAddress) > 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.signerAddress", body.SignerAddress, utf8.RuneCountInString(body.SignerAddress), 42, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.data", body.Data, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	err = goa.MergeErrors(err, goa.ValidatePattern("body.expirationTimeSeconds", body.ExpirationTimeSeconds, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(body.ExpirationTimeSeconds) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.expirationTimeSeconds", body.ExpirationTimeSeconds, utf8.RuneCountInString(body.ExpirationTimeSeconds), 100, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.gasPrice", body.GasPrice, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(body.GasPrice) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.gasPrice", body.GasPrice, utf8.RuneCountInString(body.GasPrice), 100, false))
	}
	if body.Domain != nil {
		if err2 := ValidateExchangeDomainRequestBody(body.Domain); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.signature", body.Signature, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	return
}

// ValidateExchangeDomainRequestBody runs the validations defined on
// ExchangeDomainRequestBody
func ValidateExchangeDomainRequestBody(body *ExchangeDomainRequestBody) (err error) {
	err = goa.MergeErrors(err, goa.ValidatePattern("body.verifyingContract", body.VerifyingContract, "^0x[0-9a-fA-F]{40}$"))
	if utf8.RuneCountInString(body.VerifyingContract) < 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.verifyingContract", body.VerifyingContract, utf8.RuneCountInString(body.VerifyingContract), 42, true))
	}
	if utf8.RuneCountInString(body.VerifyingContract) > 42 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.verifyingContract", body.VerifyingContract, utf8.RuneCountInString(body.VerifyingContract), 42, false))
	}
	err = goa.MergeErrors(err, goa.ValidatePattern("body.chainId", body.ChainID, "^\\d+(\\.\\d+)?$"))
	if utf8.RuneCountInString(body.ChainID) > 100 {
		err = goa.MergeErrors(err, goa.InvalidLengthError("body.chainId", body.ChainID, utf8.RuneCountInString(body.ChainID), 100, false))
	}
	return
}

// ValidateFillSignaturesResponseBody runs the validations defined on
// FillSignaturesResponseBody
func ValidateFillSignaturesResponseBody(body *FillSignaturesResponseBody) (err error) {
	if body.OrderHash == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("orderHash", "body"))
	}
	if body.ApprovalSignatures == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("approvalSignatures", "body"))
	}
	if body.ExpirationTimeSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("expirationTimeSeconds", "body"))
	}
	if body.TakerAssetFillAmount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAssetFillAmount", "body"))
	}
	if body.OrderHash != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.orderHash", *body.OrderHash, "^0x[0-9a-fA-F]{64}$"))
	}
	if body.OrderHash != nil {
		if utf8.RuneCountInString(*body.OrderHash) < 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.orderHash", *body.OrderHash, utf8.RuneCountInString(*body.OrderHash), 66, true))
		}
	}
	if body.OrderHash != nil {
		if utf8.RuneCountInString(*body.OrderHash) > 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.orderHash", *body.OrderHash, utf8.RuneCountInString(*body.OrderHash), 66, false))
		}
	}
	for _, e := range body.ApprovalSignatures {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.approvalSignatures[*]", e, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	}
	if body.ExpirationTimeSeconds != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, "^\\d+(\\.\\d+)?$"))
	}
	if body.ExpirationTimeSeconds != nil {
		if utf8.RuneCountInString(*body.ExpirationTimeSeconds) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, utf8.RuneCountInString(*body.ExpirationTimeSeconds), 100, false))
		}
	}
	if body.TakerAssetFillAmount != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAssetFillAmount", *body.TakerAssetFillAmount, "^\\d+(\\.\\d+)?$"))
	}
	if body.TakerAssetFillAmount != nil {
		if utf8.RuneCountInString(*body.TakerAssetFillAmount) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetFillAmount", *body.TakerAssetFillAmount, utf8.RuneCountInString(*body.TakerAssetFillAmount), 100, false))
		}
	}
	return
}
