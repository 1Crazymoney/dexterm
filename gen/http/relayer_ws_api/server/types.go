// Code generated by goa v3.1.1, DO NOT EDIT.
//
// RelayerWsAPI HTTP server types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-core/api/design -o ../

package server

import (
	"unicode/utf8"

	relayerwsapi "github.com/InjectiveLabs/injective-core/api/gen/relayer_ws_api"
	goa "goa.design/goa/v3/pkg"
)

// OrdersStreamingRequestBody is the type of the "RelayerWsAPI" service
// "ordersStreaming" endpoint HTTP request body.
type OrdersStreamingRequestBody struct {
	Type    *string `form:"type,omitempty" json:"type,omitempty" xml:"type,omitempty"`
	Channel *string `form:"channel,omitempty" json:"channel,omitempty" xml:"channel,omitempty"`
	// A string uuid that will be sent back by the server in response messages so
	// the client can appropriately respond when multiple subscriptions are made
	RequestID *string `form:"requestId,omitempty" json:"requestId,omitempty" xml:"requestId,omitempty"`
	// Optional payload to subscribe to all new orders and order state changes in
	// the orderbook with makerAssetData and takerAssetData equal to the values
	// specified
	Payload *OrdersStreamingSubscribePayloadSchemaRequestBody `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
}

// OrdersStreamingResponseBody is the type of the "RelayerWsAPI" service
// "ordersStreaming" endpoint HTTP response body.
type OrdersStreamingResponseBody struct {
	Type    string `form:"type" json:"type" xml:"type"`
	Channel string `form:"channel" json:"channel" xml:"channel"`
	// A string uuid that corresponds to the requestId sent by the client in the
	// subscribe message
	RequestID string `form:"requestId" json:"requestId" xml:"requestId"`
	// Array of orders
	Payload []*OrderRecordResponseBody `form:"payload,omitempty" json:"payload,omitempty" xml:"payload,omitempty"`
}

// OrdersStreamingNotFoundResponseBody is the type of the "RelayerWsAPI"
// service "ordersStreaming" endpoint HTTP response body for the "not_found"
// error.
type OrdersStreamingNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersStreamingRateLimitResponseBody is the type of the "RelayerWsAPI"
// service "ordersStreaming" endpoint HTTP response body for the "rate_limit"
// error.
type OrdersStreamingRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersStreamingInternalResponseBody is the type of the "RelayerWsAPI"
// service "ordersStreaming" endpoint HTTP response body for the "internal"
// error.
type OrdersStreamingInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersStreamingNotImplementedResponseBody is the type of the "RelayerWsAPI"
// service "ordersStreaming" endpoint HTTP response body for the
// "not_implemented" error.
type OrdersStreamingNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersStreamingValidationErrorResponseBody is the type of the "RelayerWsAPI"
// service "ordersStreaming" endpoint HTTP response body for the
// "validation_error" error.
type OrdersStreamingValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// OrderRecordResponseBody is used to define fields on response body types.
type OrderRecordResponseBody struct {
	// Order item.
	Order *OrderResponseBody `form:"order" json:"order" xml:"order"`
	// Additional meta data.
	MetaData map[string]string `form:"metaData" json:"metaData" xml:"metaData"`
}

// OrderResponseBody is used to define fields on response body types.
type OrderResponseBody struct {
	// Specify chain ID.
	ChainID int64 `form:"chainId" json:"chainId" xml:"chainId"`
	// Exchange v3 contract address.
	ExchangeAddress string `form:"exchangeAddress" json:"exchangeAddress" xml:"exchangeAddress"`
	// Address that created the order.
	MakerAddress string `form:"makerAddress" json:"makerAddress" xml:"makerAddress"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress string `form:"takerAddress" json:"takerAddress" xml:"takerAddress"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `form:"feeRecipientAddress" json:"feeRecipientAddress" xml:"feeRecipientAddress"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `form:"senderAddress" json:"senderAddress" xml:"senderAddress"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount string `form:"makerAssetAmount" json:"makerAssetAmount" xml:"makerAssetAmount"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount string `form:"takerAssetAmount" json:"takerAssetAmount" xml:"takerAssetAmount"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `form:"makerFee" json:"makerFee" xml:"makerFee"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `form:"takerFee" json:"takerFee" xml:"takerFee"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds string `form:"expirationTimeSeconds" json:"expirationTimeSeconds" xml:"expirationTimeSeconds"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt string `form:"salt" json:"salt" xml:"salt"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `form:"makerAssetData" json:"makerAssetData" xml:"makerAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `form:"takerAssetData" json:"takerAssetData" xml:"takerAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `form:"makerFeeAssetData" json:"makerFeeAssetData" xml:"makerFeeAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `form:"takerFeeAssetData" json:"takerFeeAssetData" xml:"takerFeeAssetData"`
	// Order signature.
	Signature string `form:"signature" json:"signature" xml:"signature"`
}

// SRAValidationErrorResponseBody is used to define fields on response body
// types.
type SRAValidationErrorResponseBody struct {
	// Validation error code
	Code int `form:"code" json:"code" xml:"code"`
	// Validation error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// Field name
	Field *string `form:"field,omitempty" json:"field,omitempty" xml:"field,omitempty"`
}

// OrdersStreamingSubscribePayloadSchemaRequestBody is used to define fields on
// request body types.
type OrdersStreamingSubscribePayloadSchemaRequestBody struct {
	// subscribes to new orders with the specified ABIv2 encoded makerAssetData
	MakerAssetData *string `form:"makerAssetData,omitempty" json:"makerAssetData,omitempty" xml:"makerAssetData,omitempty"`
	// subscribes to new orders with the specified ABIv2 encoded takerAssetData
	TakerAssetData *string `form:"takerAssetData,omitempty" json:"takerAssetData,omitempty" xml:"takerAssetData,omitempty"`
	// The Ethereum chain id to which you'd like to subscribe.
	ChainID *int64 `form:"chainId,omitempty" json:"chainId,omitempty" xml:"chainId,omitempty"`
}

// NewOrdersStreamingResponseBody builds the HTTP response body from the result
// of the "ordersStreaming" endpoint of the "RelayerWsAPI" service.
func NewOrdersStreamingResponseBody(res *relayerwsapi.OrdersStreamingResult) *OrdersStreamingResponseBody {
	body := &OrdersStreamingResponseBody{
		Type:      res.Type,
		Channel:   res.Channel,
		RequestID: res.RequestID,
	}
	if res.Payload != nil {
		body.Payload = make([]*OrderRecordResponseBody, len(res.Payload))
		for i, val := range res.Payload {
			body.Payload[i] = marshalRelayerwsapiOrderRecordToOrderRecordResponseBody(val)
		}
	}
	return body
}

// NewOrdersStreamingNotFoundResponseBody builds the HTTP response body from
// the result of the "ordersStreaming" endpoint of the "RelayerWsAPI" service.
func NewOrdersStreamingNotFoundResponseBody(res *goa.ServiceError) *OrdersStreamingNotFoundResponseBody {
	body := &OrdersStreamingNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersStreamingRateLimitResponseBody builds the HTTP response body from
// the result of the "ordersStreaming" endpoint of the "RelayerWsAPI" service.
func NewOrdersStreamingRateLimitResponseBody(res *goa.ServiceError) *OrdersStreamingRateLimitResponseBody {
	body := &OrdersStreamingRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersStreamingInternalResponseBody builds the HTTP response body from
// the result of the "ordersStreaming" endpoint of the "RelayerWsAPI" service.
func NewOrdersStreamingInternalResponseBody(res *goa.ServiceError) *OrdersStreamingInternalResponseBody {
	body := &OrdersStreamingInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersStreamingNotImplementedResponseBody builds the HTTP response body
// from the result of the "ordersStreaming" endpoint of the "RelayerWsAPI"
// service.
func NewOrdersStreamingNotImplementedResponseBody(res *goa.ServiceError) *OrdersStreamingNotImplementedResponseBody {
	body := &OrdersStreamingNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersStreamingValidationErrorResponseBody builds the HTTP response body
// from the result of the "ordersStreaming" endpoint of the "RelayerWsAPI"
// service.
func NewOrdersStreamingValidationErrorResponseBody(res *relayerwsapi.SRAValidationErrorResponse) *OrdersStreamingValidationErrorResponseBody {
	body := &OrdersStreamingValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerwsapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewOrdersStreamingPayload builds a RelayerWsAPI service ordersStreaming
// endpoint payload.
func NewOrdersStreamingPayload(body *OrdersStreamingRequestBody) *relayerwsapi.OrdersStreamingPayload {
	v := &relayerwsapi.OrdersStreamingPayload{
		Type:      *body.Type,
		Channel:   *body.Channel,
		RequestID: *body.RequestID,
	}
	if body.Payload != nil {
		v.Payload = unmarshalOrdersStreamingSubscribePayloadSchemaRequestBodyToRelayerwsapiOrdersStreamingSubscribePayloadSchema(body.Payload)
	}

	return v
}

// ValidateOrdersStreamingRequestBody runs the validations defined on
// OrdersStreamingRequestBody
func ValidateOrdersStreamingRequestBody(body *OrdersStreamingRequestBody) (err error) {
	if body.Type == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("type", "body"))
	}
	if body.Channel == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("channel", "body"))
	}
	if body.RequestID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("requestId", "body"))
	}
	if body.Payload != nil {
		if err2 := ValidateOrdersStreamingSubscribePayloadSchemaRequestBody(body.Payload); err2 != nil {
			err = goa.MergeErrors(err, err2)
		}
	}
	return
}

// ValidateOrdersStreamingSubscribePayloadSchemaRequestBody runs the
// validations defined on OrdersStreamingSubscribePayloadSchemaRequestBody
func ValidateOrdersStreamingSubscribePayloadSchemaRequestBody(body *OrdersStreamingSubscribePayloadSchemaRequestBody) (err error) {
	if body.MakerAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerAssetData", "body"))
	}
	if body.TakerAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAssetData", "body"))
	}
	if body.ChainID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chainId", "body"))
	}
	if body.MakerAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerAssetData", *body.MakerAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.MakerAssetData != nil {
		if utf8.RuneCountInString(*body.MakerAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetData", *body.MakerAssetData, utf8.RuneCountInString(*body.MakerAssetData), 74, true))
		}
	}
	if body.MakerAssetData != nil {
		if utf8.RuneCountInString(*body.MakerAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetData", *body.MakerAssetData, utf8.RuneCountInString(*body.MakerAssetData), 74, false))
		}
	}
	if body.TakerAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAssetData", *body.TakerAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.TakerAssetData != nil {
		if utf8.RuneCountInString(*body.TakerAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetData", *body.TakerAssetData, utf8.RuneCountInString(*body.TakerAssetData), 74, true))
		}
	}
	if body.TakerAssetData != nil {
		if utf8.RuneCountInString(*body.TakerAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetData", *body.TakerAssetData, utf8.RuneCountInString(*body.TakerAssetData), 74, false))
		}
	}
	if body.ChainID != nil {
		if !(*body.ChainID == 1 || *body.ChainID == 3 || *body.ChainID == 4 || *body.ChainID == 42 || *body.ChainID == 1337) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.chainId", *body.ChainID, []interface{}{1, 3, 4, 42, 1337}))
		}
	}
	return
}
