// Code generated by goa v3.0.9, DO NOT EDIT.
//
// Relayer HTTP client encoders and decoders
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-core/api/design -o ../../api

package client

import (
	"bytes"
	"context"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"

	relayer "github.com/InjectiveLabs/injective-core/api/gen/relayer"
	goahttp "goa.design/goa/v3/http"
)

// BuildAssetPairsRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "assetPairs" endpoint
func (c *Client) BuildAssetPairsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: AssetPairsRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "assetPairs", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeAssetPairsRequest returns an encoder for requests sent to the Relayer
// assetPairs server.
func EncodeAssetPairsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.AssetPairsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "assetPairs", "*relayer.AssetPairsPayload", v)
		}
		values := req.URL.Query()
		if p.AssetDataA != nil {
			values.Add("assetDataA", *p.AssetDataA)
		}
		if p.AssetDataB != nil {
			values.Add("assetDataB", *p.AssetDataB)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeAssetPairsResponse returns a decoder for responses returned by the
// Relayer assetPairs endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeAssetPairsResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeAssetPairsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body AssetPairsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "assetPairs", err)
			}
			err = ValidateAssetPairsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "assetPairs", err)
			}
			res := NewAssetPairsResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body AssetPairsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "assetPairs", err)
			}
			err = ValidateAssetPairsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "assetPairs", err)
			}
			return nil, NewAssetPairsNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body AssetPairsRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "assetPairs", err)
			}
			err = ValidateAssetPairsRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "assetPairs", err)
			}
			return nil, NewAssetPairsRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body AssetPairsInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "assetPairs", err)
			}
			err = ValidateAssetPairsInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "assetPairs", err)
			}
			return nil, NewAssetPairsInternal(&body)
		case http.StatusNotImplemented:
			var (
				body AssetPairsNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "assetPairs", err)
			}
			err = ValidateAssetPairsNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "assetPairs", err)
			}
			return nil, NewAssetPairsNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body AssetPairsValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "assetPairs", err)
			}
			err = ValidateAssetPairsValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "assetPairs", err)
			}
			return nil, NewAssetPairsValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "assetPairs", resp.StatusCode, string(body))
		}
	}
}

// BuildOrdersRequest instantiates a HTTP request object with method and path
// set to call the "Relayer" service "orders" endpoint
func (c *Client) BuildOrdersRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: OrdersRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "orders", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeOrdersRequest returns an encoder for requests sent to the Relayer
// orders server.
func EncodeOrdersRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.OrdersPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "orders", "*relayer.OrdersPayload", v)
		}
		values := req.URL.Query()
		if p.MakerAssetProxyID != nil {
			values.Add("makerAssetProxyId", *p.MakerAssetProxyID)
		}
		if p.TakerAssetProxyID != nil {
			values.Add("takerAssetProxyId", *p.TakerAssetProxyID)
		}
		if p.MakerAssetAddress != nil {
			values.Add("makerAssetAddress", *p.MakerAssetAddress)
		}
		if p.TakerAssetAddress != nil {
			values.Add("takerAssetAddress", *p.TakerAssetAddress)
		}
		if p.ExchangeAddress != nil {
			values.Add("exchangeAddress", *p.ExchangeAddress)
		}
		if p.SenderAddress != nil {
			values.Add("senderAddress", *p.SenderAddress)
		}
		if p.MakerAssetData != nil {
			values.Add("makerAssetData", *p.MakerAssetData)
		}
		if p.TakerAssetData != nil {
			values.Add("takerAssetData", *p.TakerAssetData)
		}
		if p.TraderAssetData != nil {
			values.Add("traderAssetData", *p.TraderAssetData)
		}
		if p.MakerAddress != nil {
			values.Add("makerAddress", *p.MakerAddress)
		}
		if p.TakerAddress != nil {
			values.Add("takerAddress", *p.TakerAddress)
		}
		if p.TraderAddress != nil {
			values.Add("traderAddress", *p.TraderAddress)
		}
		if p.FeeRecipientAddress != nil {
			values.Add("feeRecipientAddress", *p.FeeRecipientAddress)
		}
		req.URL.RawQuery = values.Encode()
		body := NewOrdersRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Relayer", "orders", err)
		}
		return nil
	}
}

// DecodeOrdersResponse returns a decoder for responses returned by the Relayer
// orders endpoint. restoreBody controls whether the response body should be
// restored after having been read.
// DecodeOrdersResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeOrdersResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body OrdersResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orders", err)
			}
			err = ValidateOrdersResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orders", err)
			}
			res := NewOrdersResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body OrdersNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orders", err)
			}
			err = ValidateOrdersNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orders", err)
			}
			return nil, NewOrdersNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body OrdersRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orders", err)
			}
			err = ValidateOrdersRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orders", err)
			}
			return nil, NewOrdersRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body OrdersInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orders", err)
			}
			err = ValidateOrdersInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orders", err)
			}
			return nil, NewOrdersInternal(&body)
		case http.StatusNotImplemented:
			var (
				body OrdersNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orders", err)
			}
			err = ValidateOrdersNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orders", err)
			}
			return nil, NewOrdersNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body OrdersValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orders", err)
			}
			err = ValidateOrdersValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orders", err)
			}
			return nil, NewOrdersValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "orders", resp.StatusCode, string(body))
		}
	}
}

// BuildOrderByHashRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "orderByHash" endpoint
func (c *Client) BuildOrderByHashRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	var (
		orderHash string
	)
	{
		p, ok := v.(*relayer.OrderByHashPayload)
		if !ok {
			return nil, goahttp.ErrInvalidType("Relayer", "orderByHash", "*relayer.OrderByHashPayload", v)
		}
		orderHash = p.OrderHash
	}
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: OrderByHashRelayerPath(orderHash)}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "orderByHash", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeOrderByHashResponse returns a decoder for responses returned by the
// Relayer orderByHash endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeOrderByHashResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeOrderByHashResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body OrderByHashResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderByHash", err)
			}
			err = ValidateOrderByHashResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderByHash", err)
			}
			res := NewOrderByHashResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body OrderByHashNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderByHash", err)
			}
			err = ValidateOrderByHashNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderByHash", err)
			}
			return nil, NewOrderByHashNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body OrderByHashRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderByHash", err)
			}
			err = ValidateOrderByHashRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderByHash", err)
			}
			return nil, NewOrderByHashRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body OrderByHashInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderByHash", err)
			}
			err = ValidateOrderByHashInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderByHash", err)
			}
			return nil, NewOrderByHashInternal(&body)
		case http.StatusNotImplemented:
			var (
				body OrderByHashNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderByHash", err)
			}
			err = ValidateOrderByHashNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderByHash", err)
			}
			return nil, NewOrderByHashNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body OrderByHashValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderByHash", err)
			}
			err = ValidateOrderByHashValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderByHash", err)
			}
			return nil, NewOrderByHashValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "orderByHash", resp.StatusCode, string(body))
		}
	}
}

// BuildOrderbookRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "orderbook" endpoint
func (c *Client) BuildOrderbookRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: OrderbookRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "orderbook", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeOrderbookRequest returns an encoder for requests sent to the Relayer
// orderbook server.
func EncodeOrderbookRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.OrderbookPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "orderbook", "*relayer.OrderbookPayload", v)
		}
		values := req.URL.Query()
		values.Add("baseAssetData", p.BaseAssetData)
		values.Add("quoteAssetData", p.QuoteAssetData)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeOrderbookResponse returns a decoder for responses returned by the
// Relayer orderbook endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeOrderbookResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeOrderbookResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body OrderbookResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderbook", err)
			}
			err = ValidateOrderbookResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderbook", err)
			}
			res := NewOrderbookResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body OrderbookNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderbook", err)
			}
			err = ValidateOrderbookNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderbook", err)
			}
			return nil, NewOrderbookNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body OrderbookRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderbook", err)
			}
			err = ValidateOrderbookRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderbook", err)
			}
			return nil, NewOrderbookRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body OrderbookInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderbook", err)
			}
			err = ValidateOrderbookInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderbook", err)
			}
			return nil, NewOrderbookInternal(&body)
		case http.StatusNotImplemented:
			var (
				body OrderbookNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderbook", err)
			}
			err = ValidateOrderbookNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderbook", err)
			}
			return nil, NewOrderbookNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body OrderbookValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderbook", err)
			}
			err = ValidateOrderbookValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderbook", err)
			}
			return nil, NewOrderbookValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "orderbook", resp.StatusCode, string(body))
		}
	}
}

// BuildOrderConfigRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "orderConfig" endpoint
func (c *Client) BuildOrderConfigRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: OrderConfigRelayerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "orderConfig", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeOrderConfigRequest returns an encoder for requests sent to the Relayer
// orderConfig server.
func EncodeOrderConfigRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.OrderConfigPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "orderConfig", "*relayer.OrderConfigPayload", v)
		}
		body := NewOrderConfigRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Relayer", "orderConfig", err)
		}
		return nil
	}
}

// DecodeOrderConfigResponse returns a decoder for responses returned by the
// Relayer orderConfig endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeOrderConfigResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeOrderConfigResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body OrderConfigResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderConfig", err)
			}
			err = ValidateOrderConfigResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderConfig", err)
			}
			res := NewOrderConfigResultCreated(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body OrderConfigNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderConfig", err)
			}
			err = ValidateOrderConfigNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderConfig", err)
			}
			return nil, NewOrderConfigNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body OrderConfigRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderConfig", err)
			}
			err = ValidateOrderConfigRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderConfig", err)
			}
			return nil, NewOrderConfigRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body OrderConfigInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderConfig", err)
			}
			err = ValidateOrderConfigInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderConfig", err)
			}
			return nil, NewOrderConfigInternal(&body)
		case http.StatusNotImplemented:
			var (
				body OrderConfigNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderConfig", err)
			}
			err = ValidateOrderConfigNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderConfig", err)
			}
			return nil, NewOrderConfigNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body OrderConfigValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "orderConfig", err)
			}
			err = ValidateOrderConfigValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "orderConfig", err)
			}
			return nil, NewOrderConfigValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "orderConfig", resp.StatusCode, string(body))
		}
	}
}

// BuildFeeRecipientsRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "feeRecipients" endpoint
func (c *Client) BuildFeeRecipientsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: FeeRecipientsRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "feeRecipients", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeFeeRecipientsResponse returns a decoder for responses returned by the
// Relayer feeRecipients endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeFeeRecipientsResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeFeeRecipientsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body FeeRecipientsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "feeRecipients", err)
			}
			err = ValidateFeeRecipientsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "feeRecipients", err)
			}
			res := NewFeeRecipientsResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body FeeRecipientsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "feeRecipients", err)
			}
			err = ValidateFeeRecipientsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "feeRecipients", err)
			}
			return nil, NewFeeRecipientsNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body FeeRecipientsRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "feeRecipients", err)
			}
			err = ValidateFeeRecipientsRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "feeRecipients", err)
			}
			return nil, NewFeeRecipientsRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body FeeRecipientsInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "feeRecipients", err)
			}
			err = ValidateFeeRecipientsInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "feeRecipients", err)
			}
			return nil, NewFeeRecipientsInternal(&body)
		case http.StatusNotImplemented:
			var (
				body FeeRecipientsNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "feeRecipients", err)
			}
			err = ValidateFeeRecipientsNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "feeRecipients", err)
			}
			return nil, NewFeeRecipientsNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body FeeRecipientsValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "feeRecipients", err)
			}
			err = ValidateFeeRecipientsValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "feeRecipients", err)
			}
			return nil, NewFeeRecipientsValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "feeRecipients", resp.StatusCode, string(body))
		}
	}
}

// BuildPostOrderRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "postOrder" endpoint
func (c *Client) BuildPostOrderRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: PostOrderRelayerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "postOrder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodePostOrderRequest returns an encoder for requests sent to the Relayer
// postOrder server.
func EncodePostOrderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.PostOrderPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "postOrder", "*relayer.PostOrderPayload", v)
		}
		body := NewPostOrderRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Relayer", "postOrder", err)
		}
		return nil
	}
}

// DecodePostOrderResponse returns a decoder for responses returned by the
// Relayer postOrder endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodePostOrderResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodePostOrderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body PostOrderResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "postOrder", err)
			}
			res := NewPostOrderResultCreated(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body PostOrderNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "postOrder", err)
			}
			err = ValidatePostOrderNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "postOrder", err)
			}
			return nil, NewPostOrderNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body PostOrderRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "postOrder", err)
			}
			err = ValidatePostOrderRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "postOrder", err)
			}
			return nil, NewPostOrderRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body PostOrderInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "postOrder", err)
			}
			err = ValidatePostOrderInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "postOrder", err)
			}
			return nil, NewPostOrderInternal(&body)
		case http.StatusNotImplemented:
			var (
				body PostOrderNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "postOrder", err)
			}
			err = ValidatePostOrderNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "postOrder", err)
			}
			return nil, NewPostOrderNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body PostOrderValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "postOrder", err)
			}
			err = ValidatePostOrderValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "postOrder", err)
			}
			return nil, NewPostOrderValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "postOrder", resp.StatusCode, string(body))
		}
	}
}

// BuildTakeOrderRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "takeOrder" endpoint
func (c *Client) BuildTakeOrderRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: TakeOrderRelayerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "takeOrder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeTakeOrderRequest returns an encoder for requests sent to the Relayer
// takeOrder server.
func EncodeTakeOrderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.TakeOrderPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "takeOrder", "*relayer.TakeOrderPayload", v)
		}
		body := NewTakeOrderRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Relayer", "takeOrder", err)
		}
		return nil
	}
}

// DecodeTakeOrderResponse returns a decoder for responses returned by the
// Relayer takeOrder endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeTakeOrderResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeTakeOrderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusCreated:
			var (
				body TakeOrderResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "takeOrder", err)
			}
			res := NewTakeOrderResultCreated(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body TakeOrderNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "takeOrder", err)
			}
			err = ValidateTakeOrderNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "takeOrder", err)
			}
			return nil, NewTakeOrderNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body TakeOrderRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "takeOrder", err)
			}
			err = ValidateTakeOrderRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "takeOrder", err)
			}
			return nil, NewTakeOrderRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body TakeOrderInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "takeOrder", err)
			}
			err = ValidateTakeOrderInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "takeOrder", err)
			}
			return nil, NewTakeOrderInternal(&body)
		case http.StatusNotImplemented:
			var (
				body TakeOrderNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "takeOrder", err)
			}
			err = ValidateTakeOrderNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "takeOrder", err)
			}
			return nil, NewTakeOrderNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body TakeOrderValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "takeOrder", err)
			}
			err = ValidateTakeOrderValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "takeOrder", err)
			}
			return nil, NewTakeOrderValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "takeOrder", resp.StatusCode, string(body))
		}
	}
}

// BuildGetActiveOrderRequest instantiates a HTTP request object with method
// and path set to call the "Relayer" service "getActiveOrder" endpoint
func (c *Client) BuildGetActiveOrderRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetActiveOrderRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "getActiveOrder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetActiveOrderRequest returns an encoder for requests sent to the
// Relayer getActiveOrder server.
func EncodeGetActiveOrderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.GetActiveOrderPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "getActiveOrder", "*relayer.GetActiveOrderPayload", v)
		}
		values := req.URL.Query()
		values.Add("orderHash", p.OrderHash)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetActiveOrderResponse returns a decoder for responses returned by the
// Relayer getActiveOrder endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeGetActiveOrderResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeGetActiveOrderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetActiveOrderResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getActiveOrder", err)
			}
			err = ValidateGetActiveOrderResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getActiveOrder", err)
			}
			res := NewGetActiveOrderResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetActiveOrderNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getActiveOrder", err)
			}
			err = ValidateGetActiveOrderNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getActiveOrder", err)
			}
			return nil, NewGetActiveOrderNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body GetActiveOrderRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getActiveOrder", err)
			}
			err = ValidateGetActiveOrderRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getActiveOrder", err)
			}
			return nil, NewGetActiveOrderRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body GetActiveOrderInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getActiveOrder", err)
			}
			err = ValidateGetActiveOrderInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getActiveOrder", err)
			}
			return nil, NewGetActiveOrderInternal(&body)
		case http.StatusNotImplemented:
			var (
				body GetActiveOrderNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getActiveOrder", err)
			}
			err = ValidateGetActiveOrderNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getActiveOrder", err)
			}
			return nil, NewGetActiveOrderNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body GetActiveOrderValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getActiveOrder", err)
			}
			err = ValidateGetActiveOrderValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getActiveOrder", err)
			}
			return nil, NewGetActiveOrderValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "getActiveOrder", resp.StatusCode, string(body))
		}
	}
}

// BuildGetArchiveOrderRequest instantiates a HTTP request object with method
// and path set to call the "Relayer" service "getArchiveOrder" endpoint
func (c *Client) BuildGetArchiveOrderRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetArchiveOrderRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "getArchiveOrder", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetArchiveOrderRequest returns an encoder for requests sent to the
// Relayer getArchiveOrder server.
func EncodeGetArchiveOrderRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.GetArchiveOrderPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "getArchiveOrder", "*relayer.GetArchiveOrderPayload", v)
		}
		values := req.URL.Query()
		values.Add("orderHash", p.OrderHash)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetArchiveOrderResponse returns a decoder for responses returned by
// the Relayer getArchiveOrder endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetArchiveOrderResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeGetArchiveOrderResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetArchiveOrderResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getArchiveOrder", err)
			}
			err = ValidateGetArchiveOrderResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getArchiveOrder", err)
			}
			res := NewGetArchiveOrderResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetArchiveOrderNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getArchiveOrder", err)
			}
			err = ValidateGetArchiveOrderNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getArchiveOrder", err)
			}
			return nil, NewGetArchiveOrderNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body GetArchiveOrderRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getArchiveOrder", err)
			}
			err = ValidateGetArchiveOrderRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getArchiveOrder", err)
			}
			return nil, NewGetArchiveOrderRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body GetArchiveOrderInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getArchiveOrder", err)
			}
			err = ValidateGetArchiveOrderInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getArchiveOrder", err)
			}
			return nil, NewGetArchiveOrderInternal(&body)
		case http.StatusNotImplemented:
			var (
				body GetArchiveOrderNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getArchiveOrder", err)
			}
			err = ValidateGetArchiveOrderNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getArchiveOrder", err)
			}
			return nil, NewGetArchiveOrderNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body GetArchiveOrderValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getArchiveOrder", err)
			}
			err = ValidateGetArchiveOrderValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getArchiveOrder", err)
			}
			return nil, NewGetArchiveOrderValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "getArchiveOrder", resp.StatusCode, string(body))
		}
	}
}

// BuildListOrdersRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "listOrders" endpoint
func (c *Client) BuildListOrdersRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListOrdersRelayerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "listOrders", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListOrdersRequest returns an encoder for requests sent to the Relayer
// listOrders server.
func EncodeListOrdersRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.ListOrdersPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "listOrders", "*relayer.ListOrdersPayload", v)
		}
		body := NewListOrdersRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Relayer", "listOrders", err)
		}
		return nil
	}
}

// DecodeListOrdersResponse returns a decoder for responses returned by the
// Relayer listOrders endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeListOrdersResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeListOrdersResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListOrdersResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listOrders", err)
			}
			err = ValidateListOrdersResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listOrders", err)
			}
			res := NewListOrdersResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body ListOrdersNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listOrders", err)
			}
			err = ValidateListOrdersNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listOrders", err)
			}
			return nil, NewListOrdersNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body ListOrdersRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listOrders", err)
			}
			err = ValidateListOrdersRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listOrders", err)
			}
			return nil, NewListOrdersRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body ListOrdersInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listOrders", err)
			}
			err = ValidateListOrdersInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listOrders", err)
			}
			return nil, NewListOrdersInternal(&body)
		case http.StatusNotImplemented:
			var (
				body ListOrdersNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listOrders", err)
			}
			err = ValidateListOrdersNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listOrders", err)
			}
			return nil, NewListOrdersNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body ListOrdersValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listOrders", err)
			}
			err = ValidateListOrdersValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listOrders", err)
			}
			return nil, NewListOrdersValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "listOrders", resp.StatusCode, string(body))
		}
	}
}

// BuildGetTradePairRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "getTradePair" endpoint
func (c *Client) BuildGetTradePairRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetTradePairRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "getTradePair", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetTradePairRequest returns an encoder for requests sent to the
// Relayer getTradePair server.
func EncodeGetTradePairRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.GetTradePairPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "getTradePair", "*relayer.GetTradePairPayload", v)
		}
		values := req.URL.Query()
		if p.Name != nil {
			values.Add("name", *p.Name)
		}
		if p.Hash != nil {
			values.Add("hash", *p.Hash)
		}
		if p.MakerAssetData != nil {
			values.Add("makerAssetData", *p.MakerAssetData)
		}
		if p.TakerAssetData != nil {
			values.Add("takerAssetData", *p.TakerAssetData)
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetTradePairResponse returns a decoder for responses returned by the
// Relayer getTradePair endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeGetTradePairResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeGetTradePairResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetTradePairResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getTradePair", err)
			}
			err = ValidateGetTradePairResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getTradePair", err)
			}
			res := NewGetTradePairResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetTradePairNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getTradePair", err)
			}
			err = ValidateGetTradePairNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getTradePair", err)
			}
			return nil, NewGetTradePairNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body GetTradePairRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getTradePair", err)
			}
			err = ValidateGetTradePairRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getTradePair", err)
			}
			return nil, NewGetTradePairRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body GetTradePairInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getTradePair", err)
			}
			err = ValidateGetTradePairInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getTradePair", err)
			}
			return nil, NewGetTradePairInternal(&body)
		case http.StatusNotImplemented:
			var (
				body GetTradePairNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getTradePair", err)
			}
			err = ValidateGetTradePairNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getTradePair", err)
			}
			return nil, NewGetTradePairNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body GetTradePairValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getTradePair", err)
			}
			err = ValidateGetTradePairValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getTradePair", err)
			}
			return nil, NewGetTradePairValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "getTradePair", resp.StatusCode, string(body))
		}
	}
}

// BuildListTradePairsRequest instantiates a HTTP request object with method
// and path set to call the "Relayer" service "listTradePairs" endpoint
func (c *Client) BuildListTradePairsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: ListTradePairsRelayerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "listTradePairs", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeListTradePairsRequest returns an encoder for requests sent to the
// Relayer listTradePairs server.
func EncodeListTradePairsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.ListTradePairsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "listTradePairs", "*relayer.ListTradePairsPayload", v)
		}
		body := NewListTradePairsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Relayer", "listTradePairs", err)
		}
		return nil
	}
}

// DecodeListTradePairsResponse returns a decoder for responses returned by the
// Relayer listTradePairs endpoint. restoreBody controls whether the response
// body should be restored after having been read.
// DecodeListTradePairsResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeListTradePairsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body ListTradePairsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listTradePairs", err)
			}
			err = ValidateListTradePairsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listTradePairs", err)
			}
			res := NewListTradePairsResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body ListTradePairsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listTradePairs", err)
			}
			err = ValidateListTradePairsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listTradePairs", err)
			}
			return nil, NewListTradePairsNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body ListTradePairsRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listTradePairs", err)
			}
			err = ValidateListTradePairsRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listTradePairs", err)
			}
			return nil, NewListTradePairsRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body ListTradePairsInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listTradePairs", err)
			}
			err = ValidateListTradePairsInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listTradePairs", err)
			}
			return nil, NewListTradePairsInternal(&body)
		case http.StatusNotImplemented:
			var (
				body ListTradePairsNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listTradePairs", err)
			}
			err = ValidateListTradePairsNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listTradePairs", err)
			}
			return nil, NewListTradePairsNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body ListTradePairsValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "listTradePairs", err)
			}
			err = ValidateListTradePairsValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "listTradePairs", err)
			}
			return nil, NewListTradePairsValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "listTradePairs", resp.StatusCode, string(body))
		}
	}
}

// BuildGetAccountRequest instantiates a HTTP request object with method and
// path set to call the "Relayer" service "getAccount" endpoint
func (c *Client) BuildGetAccountRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetAccountRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "getAccount", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetAccountRequest returns an encoder for requests sent to the Relayer
// getAccount server.
func EncodeGetAccountRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.GetAccountPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "getAccount", "*relayer.GetAccountPayload", v)
		}
		values := req.URL.Query()
		values.Add("address", p.Address)
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetAccountResponse returns a decoder for responses returned by the
// Relayer getAccount endpoint. restoreBody controls whether the response body
// should be restored after having been read.
// DecodeGetAccountResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeGetAccountResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetAccountResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getAccount", err)
			}
			err = ValidateGetAccountResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getAccount", err)
			}
			res := NewGetAccountResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetAccountNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getAccount", err)
			}
			err = ValidateGetAccountNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getAccount", err)
			}
			return nil, NewGetAccountNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body GetAccountRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getAccount", err)
			}
			err = ValidateGetAccountRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getAccount", err)
			}
			return nil, NewGetAccountRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body GetAccountInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getAccount", err)
			}
			err = ValidateGetAccountInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getAccount", err)
			}
			return nil, NewGetAccountInternal(&body)
		case http.StatusNotImplemented:
			var (
				body GetAccountNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getAccount", err)
			}
			err = ValidateGetAccountNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getAccount", err)
			}
			return nil, NewGetAccountNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body GetAccountValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getAccount", err)
			}
			err = ValidateGetAccountValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getAccount", err)
			}
			return nil, NewGetAccountValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "getAccount", resp.StatusCode, string(body))
		}
	}
}

// BuildGetOnlineAccountsRequest instantiates a HTTP request object with method
// and path set to call the "Relayer" service "getOnlineAccounts" endpoint
func (c *Client) BuildGetOnlineAccountsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetOnlineAccountsRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "getOnlineAccounts", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetOnlineAccountsRequest returns an encoder for requests sent to the
// Relayer getOnlineAccounts server.
func EncodeGetOnlineAccountsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.GetOnlineAccountsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "getOnlineAccounts", "*relayer.GetOnlineAccountsPayload", v)
		}
		values := req.URL.Query()
		if p.Version != nil {
			values.Add("version", *p.Version)
		}
		if p.Threshold != nil {
			values.Add("threshold", fmt.Sprintf("%v", *p.Threshold))
		}
		req.URL.RawQuery = values.Encode()
		return nil
	}
}

// DecodeGetOnlineAccountsResponse returns a decoder for responses returned by
// the Relayer getOnlineAccounts endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetOnlineAccountsResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeGetOnlineAccountsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetOnlineAccountsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getOnlineAccounts", err)
			}
			err = ValidateGetOnlineAccountsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getOnlineAccounts", err)
			}
			res := NewGetOnlineAccountsResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetOnlineAccountsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getOnlineAccounts", err)
			}
			err = ValidateGetOnlineAccountsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getOnlineAccounts", err)
			}
			return nil, NewGetOnlineAccountsNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body GetOnlineAccountsRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getOnlineAccounts", err)
			}
			err = ValidateGetOnlineAccountsRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getOnlineAccounts", err)
			}
			return nil, NewGetOnlineAccountsRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body GetOnlineAccountsInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getOnlineAccounts", err)
			}
			err = ValidateGetOnlineAccountsInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getOnlineAccounts", err)
			}
			return nil, NewGetOnlineAccountsInternal(&body)
		case http.StatusNotImplemented:
			var (
				body GetOnlineAccountsNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getOnlineAccounts", err)
			}
			err = ValidateGetOnlineAccountsNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getOnlineAccounts", err)
			}
			return nil, NewGetOnlineAccountsNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body GetOnlineAccountsValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getOnlineAccounts", err)
			}
			err = ValidateGetOnlineAccountsValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getOnlineAccounts", err)
			}
			return nil, NewGetOnlineAccountsValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "getOnlineAccounts", resp.StatusCode, string(body))
		}
	}
}

// BuildGetEthTransactionsRequest instantiates a HTTP request object with
// method and path set to call the "Relayer" service "getEthTransactions"
// endpoint
func (c *Client) BuildGetEthTransactionsRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: GetEthTransactionsRelayerPath()}
	req, err := http.NewRequest("POST", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "getEthTransactions", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// EncodeGetEthTransactionsRequest returns an encoder for requests sent to the
// Relayer getEthTransactions server.
func EncodeGetEthTransactionsRequest(encoder func(*http.Request) goahttp.Encoder) func(*http.Request, interface{}) error {
	return func(req *http.Request, v interface{}) error {
		p, ok := v.(*relayer.GetEthTransactionsPayload)
		if !ok {
			return goahttp.ErrInvalidType("Relayer", "getEthTransactions", "*relayer.GetEthTransactionsPayload", v)
		}
		body := NewGetEthTransactionsRequestBody(p)
		if err := encoder(req).Encode(&body); err != nil {
			return goahttp.ErrEncodingError("Relayer", "getEthTransactions", err)
		}
		return nil
	}
}

// DecodeGetEthTransactionsResponse returns a decoder for responses returned by
// the Relayer getEthTransactions endpoint. restoreBody controls whether the
// response body should be restored after having been read.
// DecodeGetEthTransactionsResponse may return the following errors:
//	- "not_found" (type *goa.ServiceError): http.StatusNotFound
//	- "rate_limit" (type *goa.ServiceError): http.StatusTooManyRequests
//	- "internal" (type *goa.ServiceError): http.StatusInternalServerError
//	- "not_implemented" (type *goa.ServiceError): http.StatusNotImplemented
//	- "validation_error" (type *relayer.ErrorBadRequest): http.StatusExpectationFailed
//	- error: internal error
func DecodeGetEthTransactionsResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body GetEthTransactionsResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getEthTransactions", err)
			}
			err = ValidateGetEthTransactionsResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getEthTransactions", err)
			}
			res := NewGetEthTransactionsResultOK(&body)
			return res, nil
		case http.StatusNotFound:
			var (
				body GetEthTransactionsNotFoundResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getEthTransactions", err)
			}
			err = ValidateGetEthTransactionsNotFoundResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getEthTransactions", err)
			}
			return nil, NewGetEthTransactionsNotFound(&body)
		case http.StatusTooManyRequests:
			var (
				body GetEthTransactionsRateLimitResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getEthTransactions", err)
			}
			err = ValidateGetEthTransactionsRateLimitResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getEthTransactions", err)
			}
			return nil, NewGetEthTransactionsRateLimit(&body)
		case http.StatusInternalServerError:
			var (
				body GetEthTransactionsInternalResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getEthTransactions", err)
			}
			err = ValidateGetEthTransactionsInternalResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getEthTransactions", err)
			}
			return nil, NewGetEthTransactionsInternal(&body)
		case http.StatusNotImplemented:
			var (
				body GetEthTransactionsNotImplementedResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getEthTransactions", err)
			}
			err = ValidateGetEthTransactionsNotImplementedResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getEthTransactions", err)
			}
			return nil, NewGetEthTransactionsNotImplemented(&body)
		case http.StatusExpectationFailed:
			var (
				body GetEthTransactionsValidationErrorResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "getEthTransactions", err)
			}
			err = ValidateGetEthTransactionsValidationErrorResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "getEthTransactions", err)
			}
			return nil, NewGetEthTransactionsValidationError(&body)
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "getEthTransactions", resp.StatusCode, string(body))
		}
	}
}

// BuildVersionRequest instantiates a HTTP request object with method and path
// set to call the "Relayer" service "version" endpoint
func (c *Client) BuildVersionRequest(ctx context.Context, v interface{}) (*http.Request, error) {
	u := &url.URL{Scheme: c.scheme, Host: c.host, Path: VersionRelayerPath()}
	req, err := http.NewRequest("GET", u.String(), nil)
	if err != nil {
		return nil, goahttp.ErrInvalidURL("Relayer", "version", u.String(), err)
	}
	if ctx != nil {
		req = req.WithContext(ctx)
	}

	return req, nil
}

// DecodeVersionResponse returns a decoder for responses returned by the
// Relayer version endpoint. restoreBody controls whether the response body
// should be restored after having been read.
func DecodeVersionResponse(decoder func(*http.Response) goahttp.Decoder, restoreBody bool) func(*http.Response) (interface{}, error) {
	return func(resp *http.Response) (interface{}, error) {
		if restoreBody {
			b, err := ioutil.ReadAll(resp.Body)
			if err != nil {
				return nil, err
			}
			resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			defer func() {
				resp.Body = ioutil.NopCloser(bytes.NewBuffer(b))
			}()
		} else {
			defer resp.Body.Close()
		}
		switch resp.StatusCode {
		case http.StatusOK:
			var (
				body VersionResponseBody
				err  error
			)
			err = decoder(resp).Decode(&body)
			if err != nil {
				return nil, goahttp.ErrDecodingError("Relayer", "version", err)
			}
			err = ValidateVersionResponseBody(&body)
			if err != nil {
				return nil, goahttp.ErrValidationError("Relayer", "version", err)
			}
			res := NewVersionResultOK(&body)
			return res, nil
		default:
			body, _ := ioutil.ReadAll(resp.Body)
			return nil, goahttp.ErrInvalidResponse("Relayer", "version", resp.StatusCode, string(body))
		}
	}
}

// unmarshalAssetPairRecordResponseBodyToRelayerAssetPairRecord builds a value
// of type *relayer.AssetPairRecord from a value of type
// *AssetPairRecordResponseBody.
func unmarshalAssetPairRecordResponseBodyToRelayerAssetPairRecord(v *AssetPairRecordResponseBody) *relayer.AssetPairRecord {
	if v == nil {
		return nil
	}
	res := &relayer.AssetPairRecord{}
	res.AssetDataA = unmarshalAssetRecordResponseBodyToRelayerAssetRecord(v.AssetDataA)
	res.AssetDataB = unmarshalAssetRecordResponseBodyToRelayerAssetRecord(v.AssetDataB)

	return res
}

// unmarshalAssetRecordResponseBodyToRelayerAssetRecord builds a value of type
// *relayer.AssetRecord from a value of type *AssetRecordResponseBody.
func unmarshalAssetRecordResponseBodyToRelayerAssetRecord(v *AssetRecordResponseBody) *relayer.AssetRecord {
	res := &relayer.AssetRecord{
		AssetData: *v.AssetData,
		MinAmount: *v.MinAmount,
		MaxAmount: *v.MaxAmount,
		Precision: *v.Precision,
	}

	return res
}

// unmarshalValidationErrorResponseBodyToRelayerValidationError builds a value
// of type *relayer.ValidationError from a value of type
// *ValidationErrorResponseBody.
func unmarshalValidationErrorResponseBodyToRelayerValidationError(v *ValidationErrorResponseBody) *relayer.ValidationError {
	if v == nil {
		return nil
	}
	res := &relayer.ValidationError{
		Code:   *v.Code,
		Reason: *v.Reason,
		Field:  v.Field,
	}

	return res
}

// unmarshalOrderRecordResponseBodyToRelayerOrderRecord builds a value of type
// *relayer.OrderRecord from a value of type *OrderRecordResponseBody.
func unmarshalOrderRecordResponseBodyToRelayerOrderRecord(v *OrderRecordResponseBody) *relayer.OrderRecord {
	if v == nil {
		return nil
	}
	res := &relayer.OrderRecord{
		MetaData: v.MetaData,
	}
	if v.Order != nil {
		res.Order = unmarshalOrderResponseBodyToRelayerOrder(v.Order)
	}

	return res
}

// unmarshalOrderResponseBodyToRelayerOrder builds a value of type
// *relayer.Order from a value of type *OrderResponseBody.
func unmarshalOrderResponseBodyToRelayerOrder(v *OrderResponseBody) *relayer.Order {
	if v == nil {
		return nil
	}
	res := &relayer.Order{
		ChainID:               *v.ChainID,
		ExchangeAddress:       *v.ExchangeAddress,
		MakerAddress:          *v.MakerAddress,
		TakerAddress:          *v.TakerAddress,
		FeeRecipientAddress:   *v.FeeRecipientAddress,
		SenderAddress:         *v.SenderAddress,
		MakerAssetAmount:      *v.MakerAssetAmount,
		TakerAssetAmount:      *v.TakerAssetAmount,
		MakerFee:              *v.MakerFee,
		TakerFee:              *v.TakerFee,
		ExpirationTimeSeconds: *v.ExpirationTimeSeconds,
		Salt:                  *v.Salt,
		MakerAssetData:        *v.MakerAssetData,
		TakerAssetData:        *v.TakerAssetData,
		MakerFeeAssetData:     *v.MakerFeeAssetData,
		TakerFeeAssetData:     *v.TakerFeeAssetData,
		Signature:             *v.Signature,
	}

	return res
}

// unmarshalOrderbookRecordsResponseBodyToRelayerOrderbookRecords builds a
// value of type *relayer.OrderbookRecords from a value of type
// *OrderbookRecordsResponseBody.
func unmarshalOrderbookRecordsResponseBodyToRelayerOrderbookRecords(v *OrderbookRecordsResponseBody) *relayer.OrderbookRecords {
	if v == nil {
		return nil
	}
	res := &relayer.OrderbookRecords{
		Total:   *v.Total,
		Page:    *v.Page,
		PerPage: *v.PerPage,
	}
	if v.Records != nil {
		res.Records = make([]*relayer.OrderRecord, len(v.Records))
		for i, val := range v.Records {
			res.Records[i] = unmarshalOrderRecordResponseBodyToRelayerOrderRecord(val)
		}
	}

	return res
}

// marshalRelayerOrderToOrderRequestBody builds a value of type
// *OrderRequestBody from a value of type *relayer.Order.
func marshalRelayerOrderToOrderRequestBody(v *relayer.Order) *OrderRequestBody {
	res := &OrderRequestBody{
		ChainID:               v.ChainID,
		ExchangeAddress:       v.ExchangeAddress,
		MakerAddress:          v.MakerAddress,
		TakerAddress:          v.TakerAddress,
		FeeRecipientAddress:   v.FeeRecipientAddress,
		SenderAddress:         v.SenderAddress,
		MakerAssetAmount:      v.MakerAssetAmount,
		TakerAssetAmount:      v.TakerAssetAmount,
		MakerFee:              v.MakerFee,
		TakerFee:              v.TakerFee,
		ExpirationTimeSeconds: v.ExpirationTimeSeconds,
		Salt:                  v.Salt,
		MakerAssetData:        v.MakerAssetData,
		TakerAssetData:        v.TakerAssetData,
		MakerFeeAssetData:     v.MakerFeeAssetData,
		TakerFeeAssetData:     v.TakerFeeAssetData,
		Signature:             v.Signature,
	}

	return res
}

// marshalOrderRequestBodyToRelayerOrder builds a value of type *relayer.Order
// from a value of type *OrderRequestBody.
func marshalOrderRequestBodyToRelayerOrder(v *OrderRequestBody) *relayer.Order {
	res := &relayer.Order{
		ChainID:               v.ChainID,
		ExchangeAddress:       v.ExchangeAddress,
		MakerAddress:          v.MakerAddress,
		TakerAddress:          v.TakerAddress,
		FeeRecipientAddress:   v.FeeRecipientAddress,
		SenderAddress:         v.SenderAddress,
		MakerAssetAmount:      v.MakerAssetAmount,
		TakerAssetAmount:      v.TakerAssetAmount,
		MakerFee:              v.MakerFee,
		TakerFee:              v.TakerFee,
		ExpirationTimeSeconds: v.ExpirationTimeSeconds,
		Salt:                  v.Salt,
		MakerAssetData:        v.MakerAssetData,
		TakerAssetData:        v.TakerAssetData,
		MakerFeeAssetData:     v.MakerFeeAssetData,
		TakerFeeAssetData:     v.TakerFeeAssetData,
		Signature:             v.Signature,
	}

	return res
}

// unmarshalTradePairResponseBodyToRelayerTradePair builds a value of type
// *relayer.TradePair from a value of type *TradePairResponseBody.
func unmarshalTradePairResponseBodyToRelayerTradePair(v *TradePairResponseBody) *relayer.TradePair {
	if v == nil {
		return nil
	}
	res := &relayer.TradePair{
		Name:           *v.Name,
		MakerAssetData: *v.MakerAssetData,
		TakerAssetData: *v.TakerAssetData,
		Hash:           *v.Hash,
		Enabled:        *v.Enabled,
	}

	return res
}

// unmarshalRelayerAccountResponseBodyToRelayerRelayerAccount builds a value of
// type *relayer.RelayerAccount from a value of type
// *RelayerAccountResponseBody.
func unmarshalRelayerAccountResponseBodyToRelayerRelayerAccount(v *RelayerAccountResponseBody) *relayer.RelayerAccount {
	if v == nil {
		return nil
	}
	res := &relayer.RelayerAccount{
		Address:     *v.Address,
		PublicKey:   *v.PublicKey,
		LastSeen:    *v.LastSeen,
		LastVersion: *v.LastVersion,
		IsOnline:    *v.IsOnline,
	}

	return res
}

// unmarshalEthTransactionResponseBodyToRelayerEthTransaction builds a value of
// type *relayer.EthTransaction from a value of type
// *EthTransactionResponseBody.
func unmarshalEthTransactionResponseBodyToRelayerEthTransaction(v *EthTransactionResponseBody) *relayer.EthTransaction {
	if v == nil {
		return nil
	}
	res := &relayer.EthTransaction{
		Proposer: *v.Proposer,
		Block:    *v.Block,
		TxHash:   v.TxHash,
		From:     v.From,
	}
	res.TradeHashes = make([]string, len(v.TradeHashes))
	for i, val := range v.TradeHashes {
		res.TradeHashes[i] = val
	}
	if v.ReviewedBy != nil {
		res.ReviewedBy = make([]string, len(v.ReviewedBy))
		for i, val := range v.ReviewedBy {
			res.ReviewedBy[i] = val
		}
	}

	return res
}
