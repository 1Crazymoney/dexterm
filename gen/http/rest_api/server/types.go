// Code generated by goa v3.1.1, DO NOT EDIT.
//
// RestAPI HTTP server types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-core/api/design -o ../

package server

import (
	"unicode/utf8"

	restapi "github.com/InjectiveLabs/injective-core/api/gen/rest_api"
	goa "goa.design/goa/v3/pkg"
)

// ListOrdersRequestBody is the type of the "RestAPI" service "listOrders"
// endpoint HTTP request body.
type ListOrdersRequestBody struct {
	// Filter by status of the order
	Status *string `form:"status,omitempty" json:"status,omitempty" xml:"status,omitempty"`
	// Filter by collection of the order
	Collection *string `form:"collection,omitempty" json:"collection,omitempty" xml:"collection,omitempty"`
	// Filter by trade pair hash
	TradePairHash *string `form:"tradePairHash,omitempty" json:"tradePairHash,omitempty" xml:"tradePairHash,omitempty"`
	// Enabled sort by VDF (1 = asc, -1 = desc)
	SortByVdf *int32 `form:"sortByVdf,omitempty" json:"sortByVdf,omitempty" xml:"sortByVdf,omitempty"`
	// Limits the amout of results by top N
	Limit *int32 `form:"limit,omitempty" json:"limit,omitempty" xml:"limit,omitempty"`
}

// ListTradePairsRequestBody is the type of the "RestAPI" service
// "listTradePairs" endpoint HTTP request body.
type ListTradePairsRequestBody struct {
	// Specify to include all trade pairs, suspended and active.
	All *bool `form:"all,omitempty" json:"all,omitempty" xml:"all,omitempty"`
}

// ListDerivativeMarketsRequestBody is the type of the "RestAPI" service
// "listDerivativeMarkets" endpoint HTTP request body.
type ListDerivativeMarketsRequestBody struct {
	// Specify to include all trade pairs, suspended and active.
	All *bool `form:"all,omitempty" json:"all,omitempty" xml:"all,omitempty"`
}

// GetActiveOrderResponseBody is the type of the "RestAPI" service
// "getActiveOrder" endpoint HTTP response body.
type GetActiveOrderResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Found active 0x order.
	Order *OrderResponseBody `form:"order,omitempty" json:"order,omitempty" xml:"order,omitempty"`
	// Additional meta data.
	MetaData interface{} `form:"metaData,omitempty" json:"metaData,omitempty" xml:"metaData,omitempty"`
}

// GetArchiveOrderResponseBody is the type of the "RestAPI" service
// "getArchiveOrder" endpoint HTTP response body.
type GetArchiveOrderResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Order item.
	Order *OrderResponseBody `form:"order" json:"order" xml:"order"`
	// Additional meta data.
	MetaData map[string]string `form:"metaData" json:"metaData" xml:"metaData"`
}

// ListOrdersResponseBody is the type of the "RestAPI" service "listOrders"
// endpoint HTTP response body.
type ListOrdersResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Filtered orders.
	Orders []*OrderResponseBody `form:"orders,omitempty" json:"orders,omitempty" xml:"orders,omitempty"`
	// Additional meta data.
	MetaData interface{} `form:"metaData,omitempty" json:"metaData,omitempty" xml:"metaData,omitempty"`
}

// GetTradePairResponseBody is the type of the "RestAPI" service "getTradePair"
// endpoint HTTP response body.
type GetTradePairResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Found trade pair.
	TradePair *TradePairResponseBody `form:"tradePair,omitempty" json:"tradePair,omitempty" xml:"tradePair,omitempty"`
	// Additional meta data.
	MetaData interface{} `form:"metaData,omitempty" json:"metaData,omitempty" xml:"metaData,omitempty"`
}

// ListTradePairsResponseBody is the type of the "RestAPI" service
// "listTradePairs" endpoint HTTP response body.
type ListTradePairsResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Filtered trade pairs.
	TradePairs []*TradePairResponseBody `form:"tradePairs,omitempty" json:"tradePairs,omitempty" xml:"tradePairs,omitempty"`
	// Additional meta data.
	MetaData interface{} `form:"metaData,omitempty" json:"metaData,omitempty" xml:"metaData,omitempty"`
}

// ListDerivativeMarketsResponseBody is the type of the "RestAPI" service
// "listDerivativeMarkets" endpoint HTTP response body.
type ListDerivativeMarketsResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Derivative Markets.
	Markets []*DerivativeMarketResponseBody `form:"markets,omitempty" json:"markets,omitempty" xml:"markets,omitempty"`
}

// GetAccountResponseBody is the type of the "RestAPI" service "getAccount"
// endpoint HTTP response body.
type GetAccountResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Found relayer account.
	Account *RelayerAccountResponseBody `form:"account,omitempty" json:"account,omitempty" xml:"account,omitempty"`
	// Additional meta data.
	MetaData interface{} `form:"metaData,omitempty" json:"metaData,omitempty" xml:"metaData,omitempty"`
}

// GetOnlineAccountsResponseBody is the type of the "RestAPI" service
// "getOnlineAccounts" endpoint HTTP response body.
type GetOnlineAccountsResponseBody struct {
	RLimitLimit     *string `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	RLimitRemaining *string `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	RLimitReset     *string `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Filtered online relayer accounts.
	Accounts []*RelayerAccountResponseBody `form:"accounts,omitempty" json:"accounts,omitempty" xml:"accounts,omitempty"`
	// Additional meta data.
	MetaData interface{} `form:"metaData,omitempty" json:"metaData,omitempty" xml:"metaData,omitempty"`
}

// GetActiveOrderNotFoundResponseBody is the type of the "RestAPI" service
// "getActiveOrder" endpoint HTTP response body for the "not_found" error.
type GetActiveOrderNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetActiveOrderInternalResponseBody is the type of the "RestAPI" service
// "getActiveOrder" endpoint HTTP response body for the "internal" error.
type GetActiveOrderInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetActiveOrderValidationErrorResponseBody is the type of the "RestAPI"
// service "getActiveOrder" endpoint HTTP response body for the
// "validation_error" error.
type GetActiveOrderValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// GetArchiveOrderNotFoundResponseBody is the type of the "RestAPI" service
// "getArchiveOrder" endpoint HTTP response body for the "not_found" error.
type GetArchiveOrderNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetArchiveOrderInternalResponseBody is the type of the "RestAPI" service
// "getArchiveOrder" endpoint HTTP response body for the "internal" error.
type GetArchiveOrderInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetArchiveOrderValidationErrorResponseBody is the type of the "RestAPI"
// service "getArchiveOrder" endpoint HTTP response body for the
// "validation_error" error.
type GetArchiveOrderValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// ListOrdersInternalResponseBody is the type of the "RestAPI" service
// "listOrders" endpoint HTTP response body for the "internal" error.
type ListOrdersInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ListOrdersValidationErrorResponseBody is the type of the "RestAPI" service
// "listOrders" endpoint HTTP response body for the "validation_error" error.
type ListOrdersValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// GetTradePairNotFoundResponseBody is the type of the "RestAPI" service
// "getTradePair" endpoint HTTP response body for the "not_found" error.
type GetTradePairNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetTradePairInternalResponseBody is the type of the "RestAPI" service
// "getTradePair" endpoint HTTP response body for the "internal" error.
type GetTradePairInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetTradePairValidationErrorResponseBody is the type of the "RestAPI" service
// "getTradePair" endpoint HTTP response body for the "validation_error" error.
type GetTradePairValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// ListTradePairsInternalResponseBody is the type of the "RestAPI" service
// "listTradePairs" endpoint HTTP response body for the "internal" error.
type ListTradePairsInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ListTradePairsValidationErrorResponseBody is the type of the "RestAPI"
// service "listTradePairs" endpoint HTTP response body for the
// "validation_error" error.
type ListTradePairsValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// ListDerivativeMarketsInternalResponseBody is the type of the "RestAPI"
// service "listDerivativeMarkets" endpoint HTTP response body for the
// "internal" error.
type ListDerivativeMarketsInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// ListDerivativeMarketsValidationErrorResponseBody is the type of the
// "RestAPI" service "listDerivativeMarkets" endpoint HTTP response body for
// the "validation_error" error.
type ListDerivativeMarketsValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// GetAccountNotFoundResponseBody is the type of the "RestAPI" service
// "getAccount" endpoint HTTP response body for the "not_found" error.
type GetAccountNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetAccountInternalResponseBody is the type of the "RestAPI" service
// "getAccount" endpoint HTTP response body for the "internal" error.
type GetAccountInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetAccountValidationErrorResponseBody is the type of the "RestAPI" service
// "getAccount" endpoint HTTP response body for the "validation_error" error.
type GetAccountValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// GetOnlineAccountsInternalResponseBody is the type of the "RestAPI" service
// "getOnlineAccounts" endpoint HTTP response body for the "internal" error.
type GetOnlineAccountsInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// GetOnlineAccountsValidationErrorResponseBody is the type of the "RestAPI"
// service "getOnlineAccounts" endpoint HTTP response body for the
// "validation_error" error.
type GetOnlineAccountsValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*RESTValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// OrderResponseBody is used to define fields on response body types.
type OrderResponseBody struct {
	// Specify chain ID.
	ChainID int64 `form:"chainId" json:"chainId" xml:"chainId"`
	// Exchange v3 contract address.
	ExchangeAddress string `form:"exchangeAddress" json:"exchangeAddress" xml:"exchangeAddress"`
	// Address that created the order.
	MakerAddress string `form:"makerAddress" json:"makerAddress" xml:"makerAddress"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress string `form:"takerAddress" json:"takerAddress" xml:"takerAddress"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `form:"feeRecipientAddress" json:"feeRecipientAddress" xml:"feeRecipientAddress"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `form:"senderAddress" json:"senderAddress" xml:"senderAddress"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount string `form:"makerAssetAmount" json:"makerAssetAmount" xml:"makerAssetAmount"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount string `form:"takerAssetAmount" json:"takerAssetAmount" xml:"takerAssetAmount"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `form:"makerFee" json:"makerFee" xml:"makerFee"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `form:"takerFee" json:"takerFee" xml:"takerFee"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds string `form:"expirationTimeSeconds" json:"expirationTimeSeconds" xml:"expirationTimeSeconds"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt string `form:"salt" json:"salt" xml:"salt"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `form:"makerAssetData" json:"makerAssetData" xml:"makerAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `form:"takerAssetData" json:"takerAssetData" xml:"takerAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `form:"makerFeeAssetData" json:"makerFeeAssetData" xml:"makerFeeAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `form:"takerFeeAssetData" json:"takerFeeAssetData" xml:"takerFeeAssetData"`
	// Order signature.
	Signature string `form:"signature" json:"signature" xml:"signature"`
}

// RESTValidationErrorResponseBody is used to define fields on response body
// types.
type RESTValidationErrorResponseBody struct {
	// Validation error code
	Code int `form:"code" json:"code" xml:"code"`
	// Validation error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// Field name
	Field *string `form:"field,omitempty" json:"field,omitempty" xml:"field,omitempty"`
}

// TradePairResponseBody is used to define fields on response body types.
type TradePairResponseBody struct {
	// A name of the pair in format AAA/BBB, where AAA - maker's asset, BBB -
	// taker's asset.
	Name string `form:"name" json:"name" xml:"name"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `form:"makerAssetData" json:"makerAssetData" xml:"makerAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `form:"takerAssetData" json:"takerAssetData" xml:"takerAssetData"`
	// Hash of both asset data, to identify the trading pair in store.
	Hash string `form:"hash" json:"hash" xml:"hash"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `form:"enabled" json:"enabled" xml:"enabled"`
}

// DerivativeMarketResponseBody is used to define fields on response body types.
type DerivativeMarketResponseBody struct {
	// Ticker for the derivative contract.
	Ticker string `form:"ticker" json:"ticker" xml:"ticker"`
	// Address of the oracle for the derivative contract
	Oracle string `form:"oracle" json:"oracle" xml:"oracle"`
	// Address of the base currency for the derivative contract
	BaseCurrency string `form:"baseCurrency" json:"baseCurrency" xml:"baseCurrency"`
	// Random number to faciltate uniqueness of the derivative market ID
	Nonce string `form:"nonce" json:"nonce" xml:"nonce"`
	// MarketID identifying the market.
	MarketID string `form:"marketID" json:"marketID" xml:"marketID"`
	// If false, then the pair is suspended and trades cannot be made.
	Enabled bool `form:"enabled" json:"enabled" xml:"enabled"`
}

// RelayerAccountResponseBody is used to define fields on response body types.
type RelayerAccountResponseBody struct {
	// Cosmos address of the relayer account.
	Address string `form:"address" json:"address" xml:"address"`
	// Ethereum address associated with this relayer account.
	StakerAddress *string `form:"stakerAddress,omitempty" json:"stakerAddress,omitempty" xml:"stakerAddress,omitempty"`
	// Public key of the relayer account, as hex string.
	PublicKey string `form:"publicKey" json:"publicKey" xml:"publicKey"`
	// Timestamp in UNIX seconds of the last time seen.
	LastSeen int64 `form:"lastSeen" json:"lastSeen" xml:"lastSeen"`
	// Last logic version seen.
	LastVersion string `form:"lastVersion" json:"lastVersion" xml:"lastVersion"`
	// A flag of liveness status of the account. Must be considered with lastSeen
	// timestamp.
	IsOnline bool `form:"isOnline" json:"isOnline" xml:"isOnline"`
}

// NewGetActiveOrderResponseBody builds the HTTP response body from the result
// of the "getActiveOrder" endpoint of the "RestAPI" service.
func NewGetActiveOrderResponseBody(res *restapi.GetActiveOrderResult) *GetActiveOrderResponseBody {
	body := &GetActiveOrderResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		MetaData:        res.MetaData,
	}
	if res.Order != nil {
		body.Order = marshalRestapiOrderToOrderResponseBody(res.Order)
	}
	return body
}

// NewGetArchiveOrderResponseBody builds the HTTP response body from the result
// of the "getArchiveOrder" endpoint of the "RestAPI" service.
func NewGetArchiveOrderResponseBody(res *restapi.GetArchiveOrderResult) *GetArchiveOrderResponseBody {
	body := &GetArchiveOrderResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
	}
	if res.Order != nil {
		body.Order = marshalRestapiOrderToOrderResponseBody(res.Order)
	}
	if res.MetaData != nil {
		body.MetaData = make(map[string]string, len(res.MetaData))
		for key, val := range res.MetaData {
			tk := key
			tv := val
			body.MetaData[tk] = tv
		}
	}
	return body
}

// NewListOrdersResponseBody builds the HTTP response body from the result of
// the "listOrders" endpoint of the "RestAPI" service.
func NewListOrdersResponseBody(res *restapi.ListOrdersResult) *ListOrdersResponseBody {
	body := &ListOrdersResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		MetaData:        res.MetaData,
	}
	if res.Orders != nil {
		body.Orders = make([]*OrderResponseBody, len(res.Orders))
		for i, val := range res.Orders {
			body.Orders[i] = marshalRestapiOrderToOrderResponseBody(val)
		}
	}
	return body
}

// NewGetTradePairResponseBody builds the HTTP response body from the result of
// the "getTradePair" endpoint of the "RestAPI" service.
func NewGetTradePairResponseBody(res *restapi.GetTradePairResult) *GetTradePairResponseBody {
	body := &GetTradePairResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		MetaData:        res.MetaData,
	}
	if res.TradePair != nil {
		body.TradePair = marshalRestapiTradePairToTradePairResponseBody(res.TradePair)
	}
	return body
}

// NewListTradePairsResponseBody builds the HTTP response body from the result
// of the "listTradePairs" endpoint of the "RestAPI" service.
func NewListTradePairsResponseBody(res *restapi.ListTradePairsResult) *ListTradePairsResponseBody {
	body := &ListTradePairsResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		MetaData:        res.MetaData,
	}
	if res.TradePairs != nil {
		body.TradePairs = make([]*TradePairResponseBody, len(res.TradePairs))
		for i, val := range res.TradePairs {
			body.TradePairs[i] = marshalRestapiTradePairToTradePairResponseBody(val)
		}
	}
	return body
}

// NewListDerivativeMarketsResponseBody builds the HTTP response body from the
// result of the "listDerivativeMarkets" endpoint of the "RestAPI" service.
func NewListDerivativeMarketsResponseBody(res *restapi.ListDerivativeMarketsResult) *ListDerivativeMarketsResponseBody {
	body := &ListDerivativeMarketsResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
	}
	if res.Markets != nil {
		body.Markets = make([]*DerivativeMarketResponseBody, len(res.Markets))
		for i, val := range res.Markets {
			body.Markets[i] = marshalRestapiDerivativeMarketToDerivativeMarketResponseBody(val)
		}
	}
	return body
}

// NewGetAccountResponseBody builds the HTTP response body from the result of
// the "getAccount" endpoint of the "RestAPI" service.
func NewGetAccountResponseBody(res *restapi.GetAccountResult) *GetAccountResponseBody {
	body := &GetAccountResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		MetaData:        res.MetaData,
	}
	if res.Account != nil {
		body.Account = marshalRestapiRelayerAccountToRelayerAccountResponseBody(res.Account)
	}
	return body
}

// NewGetOnlineAccountsResponseBody builds the HTTP response body from the
// result of the "getOnlineAccounts" endpoint of the "RestAPI" service.
func NewGetOnlineAccountsResponseBody(res *restapi.GetOnlineAccountsResult) *GetOnlineAccountsResponseBody {
	body := &GetOnlineAccountsResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		MetaData:        res.MetaData,
	}
	if res.Accounts != nil {
		body.Accounts = make([]*RelayerAccountResponseBody, len(res.Accounts))
		for i, val := range res.Accounts {
			body.Accounts[i] = marshalRestapiRelayerAccountToRelayerAccountResponseBody(val)
		}
	}
	return body
}

// NewGetActiveOrderNotFoundResponseBody builds the HTTP response body from the
// result of the "getActiveOrder" endpoint of the "RestAPI" service.
func NewGetActiveOrderNotFoundResponseBody(res *goa.ServiceError) *GetActiveOrderNotFoundResponseBody {
	body := &GetActiveOrderNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetActiveOrderInternalResponseBody builds the HTTP response body from the
// result of the "getActiveOrder" endpoint of the "RestAPI" service.
func NewGetActiveOrderInternalResponseBody(res *goa.ServiceError) *GetActiveOrderInternalResponseBody {
	body := &GetActiveOrderInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetActiveOrderValidationErrorResponseBody builds the HTTP response body
// from the result of the "getActiveOrder" endpoint of the "RestAPI" service.
func NewGetActiveOrderValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *GetActiveOrderValidationErrorResponseBody {
	body := &GetActiveOrderValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewGetArchiveOrderNotFoundResponseBody builds the HTTP response body from
// the result of the "getArchiveOrder" endpoint of the "RestAPI" service.
func NewGetArchiveOrderNotFoundResponseBody(res *goa.ServiceError) *GetArchiveOrderNotFoundResponseBody {
	body := &GetArchiveOrderNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetArchiveOrderInternalResponseBody builds the HTTP response body from
// the result of the "getArchiveOrder" endpoint of the "RestAPI" service.
func NewGetArchiveOrderInternalResponseBody(res *goa.ServiceError) *GetArchiveOrderInternalResponseBody {
	body := &GetArchiveOrderInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetArchiveOrderValidationErrorResponseBody builds the HTTP response body
// from the result of the "getArchiveOrder" endpoint of the "RestAPI" service.
func NewGetArchiveOrderValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *GetArchiveOrderValidationErrorResponseBody {
	body := &GetArchiveOrderValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewListOrdersInternalResponseBody builds the HTTP response body from the
// result of the "listOrders" endpoint of the "RestAPI" service.
func NewListOrdersInternalResponseBody(res *goa.ServiceError) *ListOrdersInternalResponseBody {
	body := &ListOrdersInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewListOrdersValidationErrorResponseBody builds the HTTP response body from
// the result of the "listOrders" endpoint of the "RestAPI" service.
func NewListOrdersValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *ListOrdersValidationErrorResponseBody {
	body := &ListOrdersValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewGetTradePairNotFoundResponseBody builds the HTTP response body from the
// result of the "getTradePair" endpoint of the "RestAPI" service.
func NewGetTradePairNotFoundResponseBody(res *goa.ServiceError) *GetTradePairNotFoundResponseBody {
	body := &GetTradePairNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetTradePairInternalResponseBody builds the HTTP response body from the
// result of the "getTradePair" endpoint of the "RestAPI" service.
func NewGetTradePairInternalResponseBody(res *goa.ServiceError) *GetTradePairInternalResponseBody {
	body := &GetTradePairInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetTradePairValidationErrorResponseBody builds the HTTP response body
// from the result of the "getTradePair" endpoint of the "RestAPI" service.
func NewGetTradePairValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *GetTradePairValidationErrorResponseBody {
	body := &GetTradePairValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewListTradePairsInternalResponseBody builds the HTTP response body from the
// result of the "listTradePairs" endpoint of the "RestAPI" service.
func NewListTradePairsInternalResponseBody(res *goa.ServiceError) *ListTradePairsInternalResponseBody {
	body := &ListTradePairsInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewListTradePairsValidationErrorResponseBody builds the HTTP response body
// from the result of the "listTradePairs" endpoint of the "RestAPI" service.
func NewListTradePairsValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *ListTradePairsValidationErrorResponseBody {
	body := &ListTradePairsValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewListDerivativeMarketsInternalResponseBody builds the HTTP response body
// from the result of the "listDerivativeMarkets" endpoint of the "RestAPI"
// service.
func NewListDerivativeMarketsInternalResponseBody(res *goa.ServiceError) *ListDerivativeMarketsInternalResponseBody {
	body := &ListDerivativeMarketsInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewListDerivativeMarketsValidationErrorResponseBody builds the HTTP response
// body from the result of the "listDerivativeMarkets" endpoint of the
// "RestAPI" service.
func NewListDerivativeMarketsValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *ListDerivativeMarketsValidationErrorResponseBody {
	body := &ListDerivativeMarketsValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewGetAccountNotFoundResponseBody builds the HTTP response body from the
// result of the "getAccount" endpoint of the "RestAPI" service.
func NewGetAccountNotFoundResponseBody(res *goa.ServiceError) *GetAccountNotFoundResponseBody {
	body := &GetAccountNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetAccountInternalResponseBody builds the HTTP response body from the
// result of the "getAccount" endpoint of the "RestAPI" service.
func NewGetAccountInternalResponseBody(res *goa.ServiceError) *GetAccountInternalResponseBody {
	body := &GetAccountInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetAccountValidationErrorResponseBody builds the HTTP response body from
// the result of the "getAccount" endpoint of the "RestAPI" service.
func NewGetAccountValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *GetAccountValidationErrorResponseBody {
	body := &GetAccountValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewGetOnlineAccountsInternalResponseBody builds the HTTP response body from
// the result of the "getOnlineAccounts" endpoint of the "RestAPI" service.
func NewGetOnlineAccountsInternalResponseBody(res *goa.ServiceError) *GetOnlineAccountsInternalResponseBody {
	body := &GetOnlineAccountsInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewGetOnlineAccountsValidationErrorResponseBody builds the HTTP response
// body from the result of the "getOnlineAccounts" endpoint of the "RestAPI"
// service.
func NewGetOnlineAccountsValidationErrorResponseBody(res *restapi.RESTValidationErrorResponse) *GetOnlineAccountsValidationErrorResponseBody {
	body := &GetOnlineAccountsValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*RESTValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRestapiRESTValidationErrorToRESTValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewGetActiveOrderPayload builds a RestAPI service getActiveOrder endpoint
// payload.
func NewGetActiveOrderPayload(orderHash string) *restapi.GetActiveOrderPayload {
	v := &restapi.GetActiveOrderPayload{}
	v.OrderHash = orderHash

	return v
}

// NewGetArchiveOrderPayload builds a RestAPI service getArchiveOrder endpoint
// payload.
func NewGetArchiveOrderPayload(orderHash string) *restapi.GetArchiveOrderPayload {
	v := &restapi.GetArchiveOrderPayload{}
	v.OrderHash = orderHash

	return v
}

// NewListOrdersPayload builds a RestAPI service listOrders endpoint payload.
func NewListOrdersPayload(body *ListOrdersRequestBody) *restapi.ListOrdersPayload {
	v := &restapi.ListOrdersPayload{
		Status:        body.Status,
		Collection:    body.Collection,
		TradePairHash: body.TradePairHash,
		SortByVdf:     body.SortByVdf,
		Limit:         body.Limit,
	}

	return v
}

// NewGetTradePairPayload builds a RestAPI service getTradePair endpoint
// payload.
func NewGetTradePairPayload(name *string, hash *string, makerAssetData *string, takerAssetData *string) *restapi.GetTradePairPayload {
	v := &restapi.GetTradePairPayload{}
	v.Name = name
	v.Hash = hash
	v.MakerAssetData = makerAssetData
	v.TakerAssetData = takerAssetData

	return v
}

// NewListTradePairsPayload builds a RestAPI service listTradePairs endpoint
// payload.
func NewListTradePairsPayload(body *ListTradePairsRequestBody) *restapi.ListTradePairsPayload {
	v := &restapi.ListTradePairsPayload{
		All: body.All,
	}

	return v
}

// NewListDerivativeMarketsPayload builds a RestAPI service
// listDerivativeMarkets endpoint payload.
func NewListDerivativeMarketsPayload(body *ListDerivativeMarketsRequestBody) *restapi.ListDerivativeMarketsPayload {
	v := &restapi.ListDerivativeMarketsPayload{
		All: body.All,
	}

	return v
}

// NewGetAccountPayload builds a RestAPI service getAccount endpoint payload.
func NewGetAccountPayload(address string) *restapi.GetAccountPayload {
	v := &restapi.GetAccountPayload{}
	v.Address = address

	return v
}

// NewGetOnlineAccountsPayload builds a RestAPI service getOnlineAccounts
// endpoint payload.
func NewGetOnlineAccountsPayload(version *string, threshold *int64) *restapi.GetOnlineAccountsPayload {
	v := &restapi.GetOnlineAccountsPayload{}
	v.Version = version
	v.Threshold = threshold

	return v
}

// ValidateListOrdersRequestBody runs the validations defined on
// ListOrdersRequestBody
func ValidateListOrdersRequestBody(body *ListOrdersRequestBody) (err error) {
	if body.Status != nil {
		if !(*body.Status == "unfilled" || *body.Status == "softCancelled" || *body.Status == "hardCancelled" || *body.Status == "softFilled" || *body.Status == "partialFilled" || *body.Status == "softPartialFilled" || *body.Status == "filled" || *body.Status == "expired") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.status", *body.Status, []interface{}{"unfilled", "softCancelled", "hardCancelled", "softFilled", "partialFilled", "softPartialFilled", "filled", "expired"}))
		}
	}
	if body.Collection != nil {
		if !(*body.Collection == "archive" || *body.Collection == "active") {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.collection", *body.Collection, []interface{}{"archive", "active"}))
		}
	}
	if body.TradePairHash != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.tradePairHash", *body.TradePairHash, "^0x[0-9a-fA-F]{64}$"))
	}
	if body.TradePairHash != nil {
		if utf8.RuneCountInString(*body.TradePairHash) < 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tradePairHash", *body.TradePairHash, utf8.RuneCountInString(*body.TradePairHash), 66, true))
		}
	}
	if body.TradePairHash != nil {
		if utf8.RuneCountInString(*body.TradePairHash) > 66 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.tradePairHash", *body.TradePairHash, utf8.RuneCountInString(*body.TradePairHash), 66, false))
		}
	}
	if body.SortByVdf != nil {
		if !(*body.SortByVdf == 0 || *body.SortByVdf == 1 || *body.SortByVdf == -1) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.sortByVdf", *body.SortByVdf, []interface{}{0, 1, -1}))
		}
	}
	return
}
