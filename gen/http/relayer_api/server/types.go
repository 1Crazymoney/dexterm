// Code generated by goa v3.1.1, DO NOT EDIT.
//
// RelayerAPI HTTP server types
//
// Command:
// $ goa gen github.com/InjectiveLabs/injective-core/api/design -o ../

package server

import (
	"unicode/utf8"

	relayerapi "github.com/InjectiveLabs/injective-core/api/gen/relayer_api"
	goa "goa.design/goa/v3/pkg"
)

// OrderConfigRequestBody is the type of the "RelayerAPI" service "orderConfig"
// endpoint HTTP request body.
type OrderConfigRequestBody struct {
	// Specify chain ID.
	ChainID *int64 `form:"chainId,omitempty" json:"chainId,omitempty" xml:"chainId,omitempty"`
	// Exchange v3 contract address.
	ExchangeAddress *string `form:"exchangeAddress,omitempty" json:"exchangeAddress,omitempty" xml:"exchangeAddress,omitempty"`
	// Address that created the order.
	MakerAddress *string `form:"makerAddress,omitempty" json:"makerAddress,omitempty" xml:"makerAddress,omitempty"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress *string `form:"takerAddress,omitempty" json:"takerAddress,omitempty" xml:"takerAddress,omitempty"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount *string `form:"makerAssetAmount,omitempty" json:"makerAssetAmount,omitempty" xml:"makerAssetAmount,omitempty"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount *string `form:"takerAssetAmount,omitempty" json:"takerAssetAmount,omitempty" xml:"takerAssetAmount,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData *string `form:"makerAssetData,omitempty" json:"makerAssetData,omitempty" xml:"makerAssetData,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData *string `form:"takerAssetData,omitempty" json:"takerAssetData,omitempty" xml:"takerAssetData,omitempty"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds *string `form:"expirationTimeSeconds,omitempty" json:"expirationTimeSeconds,omitempty" xml:"expirationTimeSeconds,omitempty"`
}

// PostOrderRequestBody is the type of the "RelayerAPI" service "postOrder"
// endpoint HTTP request body.
type PostOrderRequestBody struct {
	// Specify chain ID.
	ChainID *int64 `form:"chainId,omitempty" json:"chainId,omitempty" xml:"chainId,omitempty"`
	// Exchange v3 contract address.
	ExchangeAddress *string `form:"exchangeAddress,omitempty" json:"exchangeAddress,omitempty" xml:"exchangeAddress,omitempty"`
	// Address that created the order.
	MakerAddress *string `form:"makerAddress,omitempty" json:"makerAddress,omitempty" xml:"makerAddress,omitempty"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress *string `form:"takerAddress,omitempty" json:"takerAddress,omitempty" xml:"takerAddress,omitempty"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress *string `form:"feeRecipientAddress,omitempty" json:"feeRecipientAddress,omitempty" xml:"feeRecipientAddress,omitempty"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress *string `form:"senderAddress,omitempty" json:"senderAddress,omitempty" xml:"senderAddress,omitempty"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount *string `form:"makerAssetAmount,omitempty" json:"makerAssetAmount,omitempty" xml:"makerAssetAmount,omitempty"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount *string `form:"takerAssetAmount,omitempty" json:"takerAssetAmount,omitempty" xml:"takerAssetAmount,omitempty"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee *string `form:"makerFee,omitempty" json:"makerFee,omitempty" xml:"makerFee,omitempty"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee *string `form:"takerFee,omitempty" json:"takerFee,omitempty" xml:"takerFee,omitempty"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds *string `form:"expirationTimeSeconds,omitempty" json:"expirationTimeSeconds,omitempty" xml:"expirationTimeSeconds,omitempty"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt *string `form:"salt,omitempty" json:"salt,omitempty" xml:"salt,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData *string `form:"makerAssetData,omitempty" json:"makerAssetData,omitempty" xml:"makerAssetData,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData *string `form:"takerAssetData,omitempty" json:"takerAssetData,omitempty" xml:"takerAssetData,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData *string `form:"makerFeeAssetData,omitempty" json:"makerFeeAssetData,omitempty" xml:"makerFeeAssetData,omitempty"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData *string `form:"takerFeeAssetData,omitempty" json:"takerFeeAssetData,omitempty" xml:"takerFeeAssetData,omitempty"`
	// Order signature.
	Signature *string `form:"signature,omitempty" json:"signature,omitempty" xml:"signature,omitempty"`
}

// AssetPairsResponseBody is the type of the "RelayerAPI" service "assetPairs"
// endpoint HTTP response body.
type AssetPairsResponseBody struct {
	// The maximum number of requests you're permitted to make per hour.
	RLimitLimit *int `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	// The number of requests remaining in the current rate limit window.
	RLimitRemaining *int `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	RLimitReset *int `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Total records found in collection.
	Total int `form:"total" json:"total" xml:"total"`
	// The page number, starts from 1.
	Page int `form:"page" json:"page" xml:"page"`
	// Records limit per each page.
	PerPage int `form:"perPage" json:"perPage" xml:"perPage"`
	// Asset pairs that contain assetDataA and assetDataB (listed in any order).
	Records []*AssetPairRecordResponseBody `form:"records" json:"records" xml:"records"`
}

// OrdersResponseBody is the type of the "RelayerAPI" service "orders" endpoint
// HTTP response body.
type OrdersResponseBody struct {
	// The maximum number of requests you're permitted to make per hour.
	RLimitLimit *int `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	// The number of requests remaining in the current rate limit window.
	RLimitRemaining *int `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	RLimitReset *int `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Total records found in collection.
	Total int `form:"total" json:"total" xml:"total"`
	// The page number, starts from 1.
	Page int `form:"page" json:"page" xml:"page"`
	// Records limit per each page.
	PerPage int `form:"perPage" json:"perPage" xml:"perPage"`
	// If both makerAssetData and takerAssetData are specified, returned orders
	// will be sorted by price determined by (takerAssetAmount/makerAssetAmount).
	Records []*OrderRecordResponseBody `form:"records" json:"records" xml:"records"`
}

// OrderByHashResponseBody is the type of the "RelayerAPI" service
// "orderByHash" endpoint HTTP response body.
type OrderByHashResponseBody struct {
	// The maximum number of requests you're permitted to make per hour.
	RLimitLimit *int `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	// The number of requests remaining in the current rate limit window.
	RLimitRemaining *int `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	RLimitReset *int `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Order item.
	Order *OrderResponseBody `form:"order" json:"order" xml:"order"`
	// Additional meta data.
	MetaData map[string]string `form:"metaData" json:"metaData" xml:"metaData"`
}

// OrderbookResponseBody is the type of the "RelayerAPI" service "orderbook"
// endpoint HTTP response body.
type OrderbookResponseBody struct {
	// The maximum number of requests you're permitted to make per hour.
	RLimitLimit *int `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	// The number of requests remaining in the current rate limit window.
	RLimitRemaining *int `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	RLimitReset *int `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Array of signed orders where takerAssetData is equal to baseAssetData. Bids
	// will be sorted in descending order by price.
	Bids *SRAPaginatedOrderRecordsResponseBody `form:"bids,omitempty" json:"bids,omitempty" xml:"bids,omitempty"`
	// Array of signed orders where makerAssetData is equal to baseAssetData. Asks
	// will be sorted in ascending order by price.
	Asks *SRAPaginatedOrderRecordsResponseBody `form:"asks,omitempty" json:"asks,omitempty" xml:"asks,omitempty"`
}

// OrderConfigResponseBody is the type of the "RelayerAPI" service
// "orderConfig" endpoint HTTP response body.
type OrderConfigResponseBody struct {
	// The maximum number of requests you're permitted to make per hour.
	RLimitLimit *int `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	// The number of requests remaining in the current rate limit window.
	RLimitRemaining *int `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	RLimitReset *int `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `form:"senderAddress" json:"senderAddress" xml:"senderAddress"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `form:"feeRecipientAddress" json:"feeRecipientAddress" xml:"feeRecipientAddress"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `form:"makerFee" json:"makerFee" xml:"makerFee"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `form:"takerFee" json:"takerFee" xml:"takerFee"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `form:"makerFeeAssetData" json:"makerFeeAssetData" xml:"makerFeeAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `form:"takerFeeAssetData" json:"takerFeeAssetData" xml:"takerFeeAssetData"`
}

// FeeRecipientsResponseBody is the type of the "RelayerAPI" service
// "feeRecipients" endpoint HTTP response body.
type FeeRecipientsResponseBody struct {
	// The maximum number of requests you're permitted to make per hour.
	RLimitLimit *int `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	// The number of requests remaining in the current rate limit window.
	RLimitRemaining *int `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	RLimitReset *int `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
	// List of all fee recipient addresses for a relayer
	List []string `form:"list,omitempty" json:"list,omitempty" xml:"list,omitempty"`
}

// PostOrderResponseBody is the type of the "RelayerAPI" service "postOrder"
// endpoint HTTP response body.
type PostOrderResponseBody struct {
	// The maximum number of requests you're permitted to make per hour.
	RLimitLimit *int `form:"rLimitLimit,omitempty" json:"rLimitLimit,omitempty" xml:"rLimitLimit,omitempty"`
	// The number of requests remaining in the current rate limit window.
	RLimitRemaining *int `form:"rLimitRemaining,omitempty" json:"rLimitRemaining,omitempty" xml:"rLimitRemaining,omitempty"`
	// The time at which the current rate limit window resets in UTC epoch seconds.
	RLimitReset *int `form:"rLimitReset,omitempty" json:"rLimitReset,omitempty" xml:"rLimitReset,omitempty"`
}

// AssetPairsNotFoundResponseBody is the type of the "RelayerAPI" service
// "assetPairs" endpoint HTTP response body for the "not_found" error.
type AssetPairsNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// AssetPairsRateLimitResponseBody is the type of the "RelayerAPI" service
// "assetPairs" endpoint HTTP response body for the "rate_limit" error.
type AssetPairsRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// AssetPairsInternalResponseBody is the type of the "RelayerAPI" service
// "assetPairs" endpoint HTTP response body for the "internal" error.
type AssetPairsInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// AssetPairsNotImplementedResponseBody is the type of the "RelayerAPI" service
// "assetPairs" endpoint HTTP response body for the "not_implemented" error.
type AssetPairsNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// AssetPairsValidationErrorResponseBody is the type of the "RelayerAPI"
// service "assetPairs" endpoint HTTP response body for the "validation_error"
// error.
type AssetPairsValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// OrdersNotFoundResponseBody is the type of the "RelayerAPI" service "orders"
// endpoint HTTP response body for the "not_found" error.
type OrdersNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersRateLimitResponseBody is the type of the "RelayerAPI" service "orders"
// endpoint HTTP response body for the "rate_limit" error.
type OrdersRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersInternalResponseBody is the type of the "RelayerAPI" service "orders"
// endpoint HTTP response body for the "internal" error.
type OrdersInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersNotImplementedResponseBody is the type of the "RelayerAPI" service
// "orders" endpoint HTTP response body for the "not_implemented" error.
type OrdersNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrdersValidationErrorResponseBody is the type of the "RelayerAPI" service
// "orders" endpoint HTTP response body for the "validation_error" error.
type OrdersValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// OrderByHashNotFoundResponseBody is the type of the "RelayerAPI" service
// "orderByHash" endpoint HTTP response body for the "not_found" error.
type OrderByHashNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderByHashRateLimitResponseBody is the type of the "RelayerAPI" service
// "orderByHash" endpoint HTTP response body for the "rate_limit" error.
type OrderByHashRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderByHashInternalResponseBody is the type of the "RelayerAPI" service
// "orderByHash" endpoint HTTP response body for the "internal" error.
type OrderByHashInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderByHashNotImplementedResponseBody is the type of the "RelayerAPI"
// service "orderByHash" endpoint HTTP response body for the "not_implemented"
// error.
type OrderByHashNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderByHashValidationErrorResponseBody is the type of the "RelayerAPI"
// service "orderByHash" endpoint HTTP response body for the "validation_error"
// error.
type OrderByHashValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// OrderbookNotFoundResponseBody is the type of the "RelayerAPI" service
// "orderbook" endpoint HTTP response body for the "not_found" error.
type OrderbookNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderbookRateLimitResponseBody is the type of the "RelayerAPI" service
// "orderbook" endpoint HTTP response body for the "rate_limit" error.
type OrderbookRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderbookInternalResponseBody is the type of the "RelayerAPI" service
// "orderbook" endpoint HTTP response body for the "internal" error.
type OrderbookInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderbookNotImplementedResponseBody is the type of the "RelayerAPI" service
// "orderbook" endpoint HTTP response body for the "not_implemented" error.
type OrderbookNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderbookValidationErrorResponseBody is the type of the "RelayerAPI" service
// "orderbook" endpoint HTTP response body for the "validation_error" error.
type OrderbookValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// OrderConfigNotFoundResponseBody is the type of the "RelayerAPI" service
// "orderConfig" endpoint HTTP response body for the "not_found" error.
type OrderConfigNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderConfigRateLimitResponseBody is the type of the "RelayerAPI" service
// "orderConfig" endpoint HTTP response body for the "rate_limit" error.
type OrderConfigRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderConfigInternalResponseBody is the type of the "RelayerAPI" service
// "orderConfig" endpoint HTTP response body for the "internal" error.
type OrderConfigInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderConfigNotImplementedResponseBody is the type of the "RelayerAPI"
// service "orderConfig" endpoint HTTP response body for the "not_implemented"
// error.
type OrderConfigNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// OrderConfigValidationErrorResponseBody is the type of the "RelayerAPI"
// service "orderConfig" endpoint HTTP response body for the "validation_error"
// error.
type OrderConfigValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// FeeRecipientsNotFoundResponseBody is the type of the "RelayerAPI" service
// "feeRecipients" endpoint HTTP response body for the "not_found" error.
type FeeRecipientsNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// FeeRecipientsRateLimitResponseBody is the type of the "RelayerAPI" service
// "feeRecipients" endpoint HTTP response body for the "rate_limit" error.
type FeeRecipientsRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// FeeRecipientsInternalResponseBody is the type of the "RelayerAPI" service
// "feeRecipients" endpoint HTTP response body for the "internal" error.
type FeeRecipientsInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// FeeRecipientsNotImplementedResponseBody is the type of the "RelayerAPI"
// service "feeRecipients" endpoint HTTP response body for the
// "not_implemented" error.
type FeeRecipientsNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// FeeRecipientsValidationErrorResponseBody is the type of the "RelayerAPI"
// service "feeRecipients" endpoint HTTP response body for the
// "validation_error" error.
type FeeRecipientsValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// PostOrderNotFoundResponseBody is the type of the "RelayerAPI" service
// "postOrder" endpoint HTTP response body for the "not_found" error.
type PostOrderNotFoundResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// PostOrderRateLimitResponseBody is the type of the "RelayerAPI" service
// "postOrder" endpoint HTTP response body for the "rate_limit" error.
type PostOrderRateLimitResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// PostOrderInternalResponseBody is the type of the "RelayerAPI" service
// "postOrder" endpoint HTTP response body for the "internal" error.
type PostOrderInternalResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// PostOrderNotImplementedResponseBody is the type of the "RelayerAPI" service
// "postOrder" endpoint HTTP response body for the "not_implemented" error.
type PostOrderNotImplementedResponseBody struct {
	// Name is the name of this class of errors.
	Name string `form:"name" json:"name" xml:"name"`
	// ID is a unique identifier for this particular occurrence of the problem.
	ID string `form:"id" json:"id" xml:"id"`
	// Message is a human-readable explanation specific to this occurrence of the
	// problem.
	Message string `form:"message" json:"message" xml:"message"`
	// Is the error temporary?
	Temporary bool `form:"temporary" json:"temporary" xml:"temporary"`
	// Is the error a timeout?
	Timeout bool `form:"timeout" json:"timeout" xml:"timeout"`
	// Is the error a server-side fault?
	Fault bool `form:"fault" json:"fault" xml:"fault"`
}

// PostOrderValidationErrorResponseBody is the type of the "RelayerAPI" service
// "postOrder" endpoint HTTP response body for the "validation_error" error.
type PostOrderValidationErrorResponseBody struct {
	// General error code
	Code int `form:"code" json:"code" xml:"code"`
	// Error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// A list of explained validation errors.
	ValidationErrors []*SRAValidationErrorResponseBody `form:"validationErrors,omitempty" json:"validationErrors,omitempty" xml:"validationErrors,omitempty"`
}

// AssetPairRecordResponseBody is used to define fields on response body types.
type AssetPairRecordResponseBody struct {
	// First asset record of the pair.
	AssetDataA *AssetRecordResponseBody `form:"assetDataA" json:"assetDataA" xml:"assetDataA"`
	// Second asset record of the pair.
	AssetDataB *AssetRecordResponseBody `form:"assetDataB" json:"assetDataB" xml:"assetDataB"`
}

// AssetRecordResponseBody is used to define fields on response body types.
type AssetRecordResponseBody struct {
	// ABIv2 encoded assetData representing that token.
	AssetData string `form:"assetData" json:"assetData" xml:"assetData"`
	// The minimum trade amount the relayer will accept.
	MinAmount string `form:"minAmount" json:"minAmount" xml:"minAmount"`
	// The maximum trade amount the relayer will accept.
	MaxAmount string `form:"maxAmount" json:"maxAmount" xml:"maxAmount"`
	// The desired price precision a relayer would like to support within their
	// orderbook.
	Precision string `form:"precision" json:"precision" xml:"precision"`
}

// SRAValidationErrorResponseBody is used to define fields on response body
// types.
type SRAValidationErrorResponseBody struct {
	// Validation error code
	Code int `form:"code" json:"code" xml:"code"`
	// Validation error reason description
	Reason string `form:"reason" json:"reason" xml:"reason"`
	// Field name
	Field *string `form:"field,omitempty" json:"field,omitempty" xml:"field,omitempty"`
}

// OrderRecordResponseBody is used to define fields on response body types.
type OrderRecordResponseBody struct {
	// Order item.
	Order *OrderResponseBody `form:"order" json:"order" xml:"order"`
	// Additional meta data.
	MetaData map[string]string `form:"metaData" json:"metaData" xml:"metaData"`
}

// OrderResponseBody is used to define fields on response body types.
type OrderResponseBody struct {
	// Specify chain ID.
	ChainID int64 `form:"chainId" json:"chainId" xml:"chainId"`
	// Exchange v3 contract address.
	ExchangeAddress string `form:"exchangeAddress" json:"exchangeAddress" xml:"exchangeAddress"`
	// Address that created the order.
	MakerAddress string `form:"makerAddress" json:"makerAddress" xml:"makerAddress"`
	// Address that is allowed to fill the order. If set to 0, any address is
	// allowed to fill the order.
	TakerAddress string `form:"takerAddress" json:"takerAddress" xml:"takerAddress"`
	// Address that will receive fees when order is filled.
	FeeRecipientAddress string `form:"feeRecipientAddress" json:"feeRecipientAddress" xml:"feeRecipientAddress"`
	// Address that is allowed to call Exchange contract methods that affect this
	// order. If set to 0, any address is allowed to call these methods.
	SenderAddress string `form:"senderAddress" json:"senderAddress" xml:"senderAddress"`
	// Amount of makerAsset being offered by maker. Must be greater than 0.
	MakerAssetAmount string `form:"makerAssetAmount" json:"makerAssetAmount" xml:"makerAssetAmount"`
	// Amount of takerAsset being bid on by maker. Must be greater than 0.
	TakerAssetAmount string `form:"takerAssetAmount" json:"takerAssetAmount" xml:"takerAssetAmount"`
	// Amount of ZRX paid to feeRecipient by maker when order is filled. If set to
	// 0, no transfer of ZRX from maker to feeRecipient will be attempted.
	MakerFee string `form:"makerFee" json:"makerFee" xml:"makerFee"`
	// Amount of ZRX paid to feeRecipient by taker when order is filled. If set to
	// 0, no transfer of ZRX from taker to feeRecipient will be attempted.
	TakerFee string `form:"takerFee" json:"takerFee" xml:"takerFee"`
	// Timestamp in seconds at which order expires.
	ExpirationTimeSeconds string `form:"expirationTimeSeconds" json:"expirationTimeSeconds" xml:"expirationTimeSeconds"`
	// Arbitrary number to facilitate uniqueness of the order's hash.
	Salt string `form:"salt" json:"salt" xml:"salt"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerAsset.
	MakerAssetData string `form:"makerAssetData" json:"makerAssetData" xml:"makerAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerAsset.
	TakerAssetData string `form:"takerAssetData" json:"takerAssetData" xml:"takerAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring makerFee.
	MakerFeeAssetData string `form:"makerFeeAssetData" json:"makerFeeAssetData" xml:"makerFeeAssetData"`
	// ABIv2 encoded data that can be decoded by a specified proxy contract when
	// transferring takerFee.
	TakerFeeAssetData string `form:"takerFeeAssetData" json:"takerFeeAssetData" xml:"takerFeeAssetData"`
	// Order signature.
	Signature string `form:"signature" json:"signature" xml:"signature"`
}

// SRAPaginatedOrderRecordsResponseBody is used to define fields on response
// body types.
type SRAPaginatedOrderRecordsResponseBody struct {
	// Total records found in collection.
	Total int `form:"total" json:"total" xml:"total"`
	// The page number, starts from 1.
	Page int `form:"page" json:"page" xml:"page"`
	// Records limit per each page.
	PerPage int `form:"perPage" json:"perPage" xml:"perPage"`
	// Array of signed orders
	Records []*OrderRecordResponseBody `form:"records" json:"records" xml:"records"`
}

// NewAssetPairsResponseBody builds the HTTP response body from the result of
// the "assetPairs" endpoint of the "RelayerAPI" service.
func NewAssetPairsResponseBody(res *relayerapi.AssetPairsResult) *AssetPairsResponseBody {
	body := &AssetPairsResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		Total:           res.Total,
		Page:            res.Page,
		PerPage:         res.PerPage,
	}
	if res.Records != nil {
		body.Records = make([]*AssetPairRecordResponseBody, len(res.Records))
		for i, val := range res.Records {
			body.Records[i] = marshalRelayerapiAssetPairRecordToAssetPairRecordResponseBody(val)
		}
	}
	return body
}

// NewOrdersResponseBody builds the HTTP response body from the result of the
// "orders" endpoint of the "RelayerAPI" service.
func NewOrdersResponseBody(res *relayerapi.OrdersResult) *OrdersResponseBody {
	body := &OrdersResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
		Total:           res.Total,
		Page:            res.Page,
		PerPage:         res.PerPage,
	}
	if res.Records != nil {
		body.Records = make([]*OrderRecordResponseBody, len(res.Records))
		for i, val := range res.Records {
			body.Records[i] = marshalRelayerapiOrderRecordToOrderRecordResponseBody(val)
		}
	}
	return body
}

// NewOrderByHashResponseBody builds the HTTP response body from the result of
// the "orderByHash" endpoint of the "RelayerAPI" service.
func NewOrderByHashResponseBody(res *relayerapi.OrderByHashResult) *OrderByHashResponseBody {
	body := &OrderByHashResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
	}
	if res.Order != nil {
		body.Order = marshalRelayerapiOrderToOrderResponseBody(res.Order)
	}
	if res.MetaData != nil {
		body.MetaData = make(map[string]string, len(res.MetaData))
		for key, val := range res.MetaData {
			tk := key
			tv := val
			body.MetaData[tk] = tv
		}
	}
	return body
}

// NewOrderbookResponseBody builds the HTTP response body from the result of
// the "orderbook" endpoint of the "RelayerAPI" service.
func NewOrderbookResponseBody(res *relayerapi.OrderbookResult) *OrderbookResponseBody {
	body := &OrderbookResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
	}
	if res.Bids != nil {
		body.Bids = marshalRelayerapiSRAPaginatedOrderRecordsToSRAPaginatedOrderRecordsResponseBody(res.Bids)
	}
	if res.Asks != nil {
		body.Asks = marshalRelayerapiSRAPaginatedOrderRecordsToSRAPaginatedOrderRecordsResponseBody(res.Asks)
	}
	return body
}

// NewOrderConfigResponseBody builds the HTTP response body from the result of
// the "orderConfig" endpoint of the "RelayerAPI" service.
func NewOrderConfigResponseBody(res *relayerapi.OrderConfigResult) *OrderConfigResponseBody {
	body := &OrderConfigResponseBody{
		RLimitLimit:         res.RLimitLimit,
		RLimitRemaining:     res.RLimitRemaining,
		RLimitReset:         res.RLimitReset,
		SenderAddress:       res.SenderAddress,
		FeeRecipientAddress: res.FeeRecipientAddress,
		MakerFee:            res.MakerFee,
		TakerFee:            res.TakerFee,
		MakerFeeAssetData:   res.MakerFeeAssetData,
		TakerFeeAssetData:   res.TakerFeeAssetData,
	}
	return body
}

// NewFeeRecipientsResponseBody builds the HTTP response body from the result
// of the "feeRecipients" endpoint of the "RelayerAPI" service.
func NewFeeRecipientsResponseBody(res *relayerapi.FeeRecipientsResult) *FeeRecipientsResponseBody {
	body := &FeeRecipientsResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
	}
	if res.List != nil {
		body.List = make([]string, len(res.List))
		for i, val := range res.List {
			body.List[i] = val
		}
	}
	return body
}

// NewPostOrderResponseBody builds the HTTP response body from the result of
// the "postOrder" endpoint of the "RelayerAPI" service.
func NewPostOrderResponseBody(res *relayerapi.PostOrderResult) *PostOrderResponseBody {
	body := &PostOrderResponseBody{
		RLimitLimit:     res.RLimitLimit,
		RLimitRemaining: res.RLimitRemaining,
		RLimitReset:     res.RLimitReset,
	}
	return body
}

// NewAssetPairsNotFoundResponseBody builds the HTTP response body from the
// result of the "assetPairs" endpoint of the "RelayerAPI" service.
func NewAssetPairsNotFoundResponseBody(res *goa.ServiceError) *AssetPairsNotFoundResponseBody {
	body := &AssetPairsNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewAssetPairsRateLimitResponseBody builds the HTTP response body from the
// result of the "assetPairs" endpoint of the "RelayerAPI" service.
func NewAssetPairsRateLimitResponseBody(res *goa.ServiceError) *AssetPairsRateLimitResponseBody {
	body := &AssetPairsRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewAssetPairsInternalResponseBody builds the HTTP response body from the
// result of the "assetPairs" endpoint of the "RelayerAPI" service.
func NewAssetPairsInternalResponseBody(res *goa.ServiceError) *AssetPairsInternalResponseBody {
	body := &AssetPairsInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewAssetPairsNotImplementedResponseBody builds the HTTP response body from
// the result of the "assetPairs" endpoint of the "RelayerAPI" service.
func NewAssetPairsNotImplementedResponseBody(res *goa.ServiceError) *AssetPairsNotImplementedResponseBody {
	body := &AssetPairsNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewAssetPairsValidationErrorResponseBody builds the HTTP response body from
// the result of the "assetPairs" endpoint of the "RelayerAPI" service.
func NewAssetPairsValidationErrorResponseBody(res *relayerapi.SRAValidationErrorResponse) *AssetPairsValidationErrorResponseBody {
	body := &AssetPairsValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewOrdersNotFoundResponseBody builds the HTTP response body from the result
// of the "orders" endpoint of the "RelayerAPI" service.
func NewOrdersNotFoundResponseBody(res *goa.ServiceError) *OrdersNotFoundResponseBody {
	body := &OrdersNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersRateLimitResponseBody builds the HTTP response body from the result
// of the "orders" endpoint of the "RelayerAPI" service.
func NewOrdersRateLimitResponseBody(res *goa.ServiceError) *OrdersRateLimitResponseBody {
	body := &OrdersRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersInternalResponseBody builds the HTTP response body from the result
// of the "orders" endpoint of the "RelayerAPI" service.
func NewOrdersInternalResponseBody(res *goa.ServiceError) *OrdersInternalResponseBody {
	body := &OrdersInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersNotImplementedResponseBody builds the HTTP response body from the
// result of the "orders" endpoint of the "RelayerAPI" service.
func NewOrdersNotImplementedResponseBody(res *goa.ServiceError) *OrdersNotImplementedResponseBody {
	body := &OrdersNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrdersValidationErrorResponseBody builds the HTTP response body from the
// result of the "orders" endpoint of the "RelayerAPI" service.
func NewOrdersValidationErrorResponseBody(res *relayerapi.SRAValidationErrorResponse) *OrdersValidationErrorResponseBody {
	body := &OrdersValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewOrderByHashNotFoundResponseBody builds the HTTP response body from the
// result of the "orderByHash" endpoint of the "RelayerAPI" service.
func NewOrderByHashNotFoundResponseBody(res *goa.ServiceError) *OrderByHashNotFoundResponseBody {
	body := &OrderByHashNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderByHashRateLimitResponseBody builds the HTTP response body from the
// result of the "orderByHash" endpoint of the "RelayerAPI" service.
func NewOrderByHashRateLimitResponseBody(res *goa.ServiceError) *OrderByHashRateLimitResponseBody {
	body := &OrderByHashRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderByHashInternalResponseBody builds the HTTP response body from the
// result of the "orderByHash" endpoint of the "RelayerAPI" service.
func NewOrderByHashInternalResponseBody(res *goa.ServiceError) *OrderByHashInternalResponseBody {
	body := &OrderByHashInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderByHashNotImplementedResponseBody builds the HTTP response body from
// the result of the "orderByHash" endpoint of the "RelayerAPI" service.
func NewOrderByHashNotImplementedResponseBody(res *goa.ServiceError) *OrderByHashNotImplementedResponseBody {
	body := &OrderByHashNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderByHashValidationErrorResponseBody builds the HTTP response body from
// the result of the "orderByHash" endpoint of the "RelayerAPI" service.
func NewOrderByHashValidationErrorResponseBody(res *relayerapi.SRAValidationErrorResponse) *OrderByHashValidationErrorResponseBody {
	body := &OrderByHashValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewOrderbookNotFoundResponseBody builds the HTTP response body from the
// result of the "orderbook" endpoint of the "RelayerAPI" service.
func NewOrderbookNotFoundResponseBody(res *goa.ServiceError) *OrderbookNotFoundResponseBody {
	body := &OrderbookNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderbookRateLimitResponseBody builds the HTTP response body from the
// result of the "orderbook" endpoint of the "RelayerAPI" service.
func NewOrderbookRateLimitResponseBody(res *goa.ServiceError) *OrderbookRateLimitResponseBody {
	body := &OrderbookRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderbookInternalResponseBody builds the HTTP response body from the
// result of the "orderbook" endpoint of the "RelayerAPI" service.
func NewOrderbookInternalResponseBody(res *goa.ServiceError) *OrderbookInternalResponseBody {
	body := &OrderbookInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderbookNotImplementedResponseBody builds the HTTP response body from
// the result of the "orderbook" endpoint of the "RelayerAPI" service.
func NewOrderbookNotImplementedResponseBody(res *goa.ServiceError) *OrderbookNotImplementedResponseBody {
	body := &OrderbookNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderbookValidationErrorResponseBody builds the HTTP response body from
// the result of the "orderbook" endpoint of the "RelayerAPI" service.
func NewOrderbookValidationErrorResponseBody(res *relayerapi.SRAValidationErrorResponse) *OrderbookValidationErrorResponseBody {
	body := &OrderbookValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewOrderConfigNotFoundResponseBody builds the HTTP response body from the
// result of the "orderConfig" endpoint of the "RelayerAPI" service.
func NewOrderConfigNotFoundResponseBody(res *goa.ServiceError) *OrderConfigNotFoundResponseBody {
	body := &OrderConfigNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderConfigRateLimitResponseBody builds the HTTP response body from the
// result of the "orderConfig" endpoint of the "RelayerAPI" service.
func NewOrderConfigRateLimitResponseBody(res *goa.ServiceError) *OrderConfigRateLimitResponseBody {
	body := &OrderConfigRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderConfigInternalResponseBody builds the HTTP response body from the
// result of the "orderConfig" endpoint of the "RelayerAPI" service.
func NewOrderConfigInternalResponseBody(res *goa.ServiceError) *OrderConfigInternalResponseBody {
	body := &OrderConfigInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderConfigNotImplementedResponseBody builds the HTTP response body from
// the result of the "orderConfig" endpoint of the "RelayerAPI" service.
func NewOrderConfigNotImplementedResponseBody(res *goa.ServiceError) *OrderConfigNotImplementedResponseBody {
	body := &OrderConfigNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewOrderConfigValidationErrorResponseBody builds the HTTP response body from
// the result of the "orderConfig" endpoint of the "RelayerAPI" service.
func NewOrderConfigValidationErrorResponseBody(res *relayerapi.SRAValidationErrorResponse) *OrderConfigValidationErrorResponseBody {
	body := &OrderConfigValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewFeeRecipientsNotFoundResponseBody builds the HTTP response body from the
// result of the "feeRecipients" endpoint of the "RelayerAPI" service.
func NewFeeRecipientsNotFoundResponseBody(res *goa.ServiceError) *FeeRecipientsNotFoundResponseBody {
	body := &FeeRecipientsNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewFeeRecipientsRateLimitResponseBody builds the HTTP response body from the
// result of the "feeRecipients" endpoint of the "RelayerAPI" service.
func NewFeeRecipientsRateLimitResponseBody(res *goa.ServiceError) *FeeRecipientsRateLimitResponseBody {
	body := &FeeRecipientsRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewFeeRecipientsInternalResponseBody builds the HTTP response body from the
// result of the "feeRecipients" endpoint of the "RelayerAPI" service.
func NewFeeRecipientsInternalResponseBody(res *goa.ServiceError) *FeeRecipientsInternalResponseBody {
	body := &FeeRecipientsInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewFeeRecipientsNotImplementedResponseBody builds the HTTP response body
// from the result of the "feeRecipients" endpoint of the "RelayerAPI" service.
func NewFeeRecipientsNotImplementedResponseBody(res *goa.ServiceError) *FeeRecipientsNotImplementedResponseBody {
	body := &FeeRecipientsNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewFeeRecipientsValidationErrorResponseBody builds the HTTP response body
// from the result of the "feeRecipients" endpoint of the "RelayerAPI" service.
func NewFeeRecipientsValidationErrorResponseBody(res *relayerapi.SRAValidationErrorResponse) *FeeRecipientsValidationErrorResponseBody {
	body := &FeeRecipientsValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewPostOrderNotFoundResponseBody builds the HTTP response body from the
// result of the "postOrder" endpoint of the "RelayerAPI" service.
func NewPostOrderNotFoundResponseBody(res *goa.ServiceError) *PostOrderNotFoundResponseBody {
	body := &PostOrderNotFoundResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewPostOrderRateLimitResponseBody builds the HTTP response body from the
// result of the "postOrder" endpoint of the "RelayerAPI" service.
func NewPostOrderRateLimitResponseBody(res *goa.ServiceError) *PostOrderRateLimitResponseBody {
	body := &PostOrderRateLimitResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewPostOrderInternalResponseBody builds the HTTP response body from the
// result of the "postOrder" endpoint of the "RelayerAPI" service.
func NewPostOrderInternalResponseBody(res *goa.ServiceError) *PostOrderInternalResponseBody {
	body := &PostOrderInternalResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewPostOrderNotImplementedResponseBody builds the HTTP response body from
// the result of the "postOrder" endpoint of the "RelayerAPI" service.
func NewPostOrderNotImplementedResponseBody(res *goa.ServiceError) *PostOrderNotImplementedResponseBody {
	body := &PostOrderNotImplementedResponseBody{
		Name:      res.Name,
		ID:        res.ID,
		Message:   res.Message,
		Temporary: res.Temporary,
		Timeout:   res.Timeout,
		Fault:     res.Fault,
	}
	return body
}

// NewPostOrderValidationErrorResponseBody builds the HTTP response body from
// the result of the "postOrder" endpoint of the "RelayerAPI" service.
func NewPostOrderValidationErrorResponseBody(res *relayerapi.SRAValidationErrorResponse) *PostOrderValidationErrorResponseBody {
	body := &PostOrderValidationErrorResponseBody{
		Code:   res.Code,
		Reason: res.Reason,
	}
	if res.ValidationErrors != nil {
		body.ValidationErrors = make([]*SRAValidationErrorResponseBody, len(res.ValidationErrors))
		for i, val := range res.ValidationErrors {
			body.ValidationErrors[i] = marshalRelayerapiSRAValidationErrorToSRAValidationErrorResponseBody(val)
		}
	}
	return body
}

// NewAssetPairsPayload builds a RelayerAPI service assetPairs endpoint payload.
func NewAssetPairsPayload(assetDataA *string, assetDataB *string, page int, perPage int) *relayerapi.AssetPairsPayload {
	v := &relayerapi.AssetPairsPayload{}
	v.AssetDataA = assetDataA
	v.AssetDataB = assetDataB
	v.Page = page
	v.PerPage = perPage

	return v
}

// NewOrdersPayload builds a RelayerAPI service orders endpoint payload.
func NewOrdersPayload(page int, perPage int, makerAssetProxyID *string, takerAssetProxyID *string, makerAssetAddress *string, takerAssetAddress *string, exchangeAddress *string, senderAddress *string, makerAssetData *string, takerAssetData *string, traderAssetData *string, makerAddress *string, takerAddress *string, makerFeeAssetData *string, takerFeeAssetData *string, traderAddress *string, feeRecipientAddress *string) *relayerapi.OrdersPayload {
	v := &relayerapi.OrdersPayload{}
	v.Page = page
	v.PerPage = perPage
	v.MakerAssetProxyID = makerAssetProxyID
	v.TakerAssetProxyID = takerAssetProxyID
	v.MakerAssetAddress = makerAssetAddress
	v.TakerAssetAddress = takerAssetAddress
	v.ExchangeAddress = exchangeAddress
	v.SenderAddress = senderAddress
	v.MakerAssetData = makerAssetData
	v.TakerAssetData = takerAssetData
	v.TraderAssetData = traderAssetData
	v.MakerAddress = makerAddress
	v.TakerAddress = takerAddress
	v.MakerFeeAssetData = makerFeeAssetData
	v.TakerFeeAssetData = takerFeeAssetData
	v.TraderAddress = traderAddress
	v.FeeRecipientAddress = feeRecipientAddress

	return v
}

// NewOrderByHashPayload builds a RelayerAPI service orderByHash endpoint
// payload.
func NewOrderByHashPayload(orderHash string) *relayerapi.OrderByHashPayload {
	v := &relayerapi.OrderByHashPayload{}
	v.OrderHash = orderHash

	return v
}

// NewOrderbookPayload builds a RelayerAPI service orderbook endpoint payload.
func NewOrderbookPayload(page int, perPage int, baseAssetData string, quoteAssetData string) *relayerapi.OrderbookPayload {
	v := &relayerapi.OrderbookPayload{}
	v.Page = page
	v.PerPage = perPage
	v.BaseAssetData = baseAssetData
	v.QuoteAssetData = quoteAssetData

	return v
}

// NewOrderConfigPayload builds a RelayerAPI service orderConfig endpoint
// payload.
func NewOrderConfigPayload(body *OrderConfigRequestBody) *relayerapi.OrderConfigPayload {
	v := &relayerapi.OrderConfigPayload{
		ExchangeAddress:       *body.ExchangeAddress,
		MakerAddress:          *body.MakerAddress,
		TakerAddress:          *body.TakerAddress,
		MakerAssetAmount:      *body.MakerAssetAmount,
		TakerAssetAmount:      *body.TakerAssetAmount,
		MakerAssetData:        *body.MakerAssetData,
		TakerAssetData:        *body.TakerAssetData,
		ExpirationTimeSeconds: *body.ExpirationTimeSeconds,
	}
	if body.ChainID != nil {
		v.ChainID = *body.ChainID
	}
	if body.ChainID == nil {
		v.ChainID = 1337
	}

	return v
}

// NewFeeRecipientsSRARequest builds a RelayerAPI service feeRecipients
// endpoint payload.
func NewFeeRecipientsSRARequest() *relayerapi.SRARequest {
	v := &relayerapi.SRARequest{}

	return v
}

// NewPostOrderPayload builds a RelayerAPI service postOrder endpoint payload.
func NewPostOrderPayload(body *PostOrderRequestBody) *relayerapi.PostOrderPayload {
	v := &relayerapi.PostOrderPayload{
		ChainID:               *body.ChainID,
		ExchangeAddress:       *body.ExchangeAddress,
		MakerAddress:          *body.MakerAddress,
		TakerAddress:          *body.TakerAddress,
		FeeRecipientAddress:   *body.FeeRecipientAddress,
		SenderAddress:         *body.SenderAddress,
		MakerAssetAmount:      *body.MakerAssetAmount,
		TakerAssetAmount:      *body.TakerAssetAmount,
		MakerFee:              *body.MakerFee,
		TakerFee:              *body.TakerFee,
		ExpirationTimeSeconds: *body.ExpirationTimeSeconds,
		Salt:                  *body.Salt,
		MakerAssetData:        *body.MakerAssetData,
		TakerAssetData:        *body.TakerAssetData,
		MakerFeeAssetData:     *body.MakerFeeAssetData,
		TakerFeeAssetData:     *body.TakerFeeAssetData,
		Signature:             *body.Signature,
	}

	return v
}

// ValidateOrderConfigRequestBody runs the validations defined on
// OrderConfigRequestBody
func ValidateOrderConfigRequestBody(body *OrderConfigRequestBody) (err error) {
	if body.ExchangeAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("exchangeAddress", "body"))
	}
	if body.MakerAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerAddress", "body"))
	}
	if body.TakerAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAddress", "body"))
	}
	if body.MakerAssetAmount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerAssetAmount", "body"))
	}
	if body.TakerAssetAmount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAssetAmount", "body"))
	}
	if body.MakerAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerAssetData", "body"))
	}
	if body.TakerAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAssetData", "body"))
	}
	if body.ExpirationTimeSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("expirationTimeSeconds", "body"))
	}
	if body.ChainID != nil {
		if !(*body.ChainID == 1 || *body.ChainID == 3 || *body.ChainID == 4 || *body.ChainID == 42 || *body.ChainID == 1337) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.chainId", *body.ChainID, []interface{}{1, 3, 4, 42, 1337}))
		}
	}
	if body.ExchangeAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.exchangeAddress", *body.ExchangeAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.ExchangeAddress != nil {
		if utf8.RuneCountInString(*body.ExchangeAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.exchangeAddress", *body.ExchangeAddress, utf8.RuneCountInString(*body.ExchangeAddress), 42, true))
		}
	}
	if body.ExchangeAddress != nil {
		if utf8.RuneCountInString(*body.ExchangeAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.exchangeAddress", *body.ExchangeAddress, utf8.RuneCountInString(*body.ExchangeAddress), 42, false))
		}
	}
	if body.MakerAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerAddress", *body.MakerAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.MakerAddress != nil {
		if utf8.RuneCountInString(*body.MakerAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAddress", *body.MakerAddress, utf8.RuneCountInString(*body.MakerAddress), 42, true))
		}
	}
	if body.MakerAddress != nil {
		if utf8.RuneCountInString(*body.MakerAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAddress", *body.MakerAddress, utf8.RuneCountInString(*body.MakerAddress), 42, false))
		}
	}
	if body.TakerAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAddress", *body.TakerAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.TakerAddress != nil {
		if utf8.RuneCountInString(*body.TakerAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAddress", *body.TakerAddress, utf8.RuneCountInString(*body.TakerAddress), 42, true))
		}
	}
	if body.TakerAddress != nil {
		if utf8.RuneCountInString(*body.TakerAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAddress", *body.TakerAddress, utf8.RuneCountInString(*body.TakerAddress), 42, false))
		}
	}
	if body.MakerAssetAmount != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerAssetAmount", *body.MakerAssetAmount, "^\\d+(\\.\\d+)?$"))
	}
	if body.MakerAssetAmount != nil {
		if utf8.RuneCountInString(*body.MakerAssetAmount) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetAmount", *body.MakerAssetAmount, utf8.RuneCountInString(*body.MakerAssetAmount), 100, false))
		}
	}
	if body.TakerAssetAmount != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAssetAmount", *body.TakerAssetAmount, "^\\d+(\\.\\d+)?$"))
	}
	if body.TakerAssetAmount != nil {
		if utf8.RuneCountInString(*body.TakerAssetAmount) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetAmount", *body.TakerAssetAmount, utf8.RuneCountInString(*body.TakerAssetAmount), 100, false))
		}
	}
	if body.MakerAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerAssetData", *body.MakerAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.MakerAssetData != nil {
		if utf8.RuneCountInString(*body.MakerAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetData", *body.MakerAssetData, utf8.RuneCountInString(*body.MakerAssetData), 74, true))
		}
	}
	if body.MakerAssetData != nil {
		if utf8.RuneCountInString(*body.MakerAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetData", *body.MakerAssetData, utf8.RuneCountInString(*body.MakerAssetData), 74, false))
		}
	}
	if body.TakerAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAssetData", *body.TakerAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.TakerAssetData != nil {
		if utf8.RuneCountInString(*body.TakerAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetData", *body.TakerAssetData, utf8.RuneCountInString(*body.TakerAssetData), 74, true))
		}
	}
	if body.TakerAssetData != nil {
		if utf8.RuneCountInString(*body.TakerAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetData", *body.TakerAssetData, utf8.RuneCountInString(*body.TakerAssetData), 74, false))
		}
	}
	if body.ExpirationTimeSeconds != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, "^\\d+(\\.\\d+)?$"))
	}
	if body.ExpirationTimeSeconds != nil {
		if utf8.RuneCountInString(*body.ExpirationTimeSeconds) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, utf8.RuneCountInString(*body.ExpirationTimeSeconds), 100, false))
		}
	}
	return
}

// ValidatePostOrderRequestBody runs the validations defined on
// PostOrderRequestBody
func ValidatePostOrderRequestBody(body *PostOrderRequestBody) (err error) {
	if body.ChainID == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("chainId", "body"))
	}
	if body.ExchangeAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("exchangeAddress", "body"))
	}
	if body.MakerAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerAddress", "body"))
	}
	if body.TakerAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAddress", "body"))
	}
	if body.FeeRecipientAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("feeRecipientAddress", "body"))
	}
	if body.SenderAddress == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("senderAddress", "body"))
	}
	if body.MakerAssetAmount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerAssetAmount", "body"))
	}
	if body.TakerAssetAmount == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAssetAmount", "body"))
	}
	if body.MakerFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerFee", "body"))
	}
	if body.TakerFee == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerFee", "body"))
	}
	if body.ExpirationTimeSeconds == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("expirationTimeSeconds", "body"))
	}
	if body.Salt == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("salt", "body"))
	}
	if body.MakerAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerAssetData", "body"))
	}
	if body.TakerAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerAssetData", "body"))
	}
	if body.MakerFeeAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("makerFeeAssetData", "body"))
	}
	if body.TakerFeeAssetData == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("takerFeeAssetData", "body"))
	}
	if body.Signature == nil {
		err = goa.MergeErrors(err, goa.MissingFieldError("signature", "body"))
	}
	if body.ChainID != nil {
		if !(*body.ChainID == 1 || *body.ChainID == 3 || *body.ChainID == 4 || *body.ChainID == 42 || *body.ChainID == 1337) {
			err = goa.MergeErrors(err, goa.InvalidEnumValueError("body.chainId", *body.ChainID, []interface{}{1, 3, 4, 42, 1337}))
		}
	}
	if body.ExchangeAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.exchangeAddress", *body.ExchangeAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.ExchangeAddress != nil {
		if utf8.RuneCountInString(*body.ExchangeAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.exchangeAddress", *body.ExchangeAddress, utf8.RuneCountInString(*body.ExchangeAddress), 42, true))
		}
	}
	if body.ExchangeAddress != nil {
		if utf8.RuneCountInString(*body.ExchangeAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.exchangeAddress", *body.ExchangeAddress, utf8.RuneCountInString(*body.ExchangeAddress), 42, false))
		}
	}
	if body.MakerAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerAddress", *body.MakerAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.MakerAddress != nil {
		if utf8.RuneCountInString(*body.MakerAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAddress", *body.MakerAddress, utf8.RuneCountInString(*body.MakerAddress), 42, true))
		}
	}
	if body.MakerAddress != nil {
		if utf8.RuneCountInString(*body.MakerAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAddress", *body.MakerAddress, utf8.RuneCountInString(*body.MakerAddress), 42, false))
		}
	}
	if body.TakerAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAddress", *body.TakerAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.TakerAddress != nil {
		if utf8.RuneCountInString(*body.TakerAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAddress", *body.TakerAddress, utf8.RuneCountInString(*body.TakerAddress), 42, true))
		}
	}
	if body.TakerAddress != nil {
		if utf8.RuneCountInString(*body.TakerAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAddress", *body.TakerAddress, utf8.RuneCountInString(*body.TakerAddress), 42, false))
		}
	}
	if body.FeeRecipientAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.feeRecipientAddress", *body.FeeRecipientAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.FeeRecipientAddress != nil {
		if utf8.RuneCountInString(*body.FeeRecipientAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.feeRecipientAddress", *body.FeeRecipientAddress, utf8.RuneCountInString(*body.FeeRecipientAddress), 42, true))
		}
	}
	if body.FeeRecipientAddress != nil {
		if utf8.RuneCountInString(*body.FeeRecipientAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.feeRecipientAddress", *body.FeeRecipientAddress, utf8.RuneCountInString(*body.FeeRecipientAddress), 42, false))
		}
	}
	if body.SenderAddress != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.senderAddress", *body.SenderAddress, "^0x[0-9a-fA-F]{40}$"))
	}
	if body.SenderAddress != nil {
		if utf8.RuneCountInString(*body.SenderAddress) < 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.senderAddress", *body.SenderAddress, utf8.RuneCountInString(*body.SenderAddress), 42, true))
		}
	}
	if body.SenderAddress != nil {
		if utf8.RuneCountInString(*body.SenderAddress) > 42 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.senderAddress", *body.SenderAddress, utf8.RuneCountInString(*body.SenderAddress), 42, false))
		}
	}
	if body.MakerAssetAmount != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerAssetAmount", *body.MakerAssetAmount, "^\\d+(\\.\\d+)?$"))
	}
	if body.MakerAssetAmount != nil {
		if utf8.RuneCountInString(*body.MakerAssetAmount) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetAmount", *body.MakerAssetAmount, utf8.RuneCountInString(*body.MakerAssetAmount), 100, false))
		}
	}
	if body.TakerAssetAmount != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAssetAmount", *body.TakerAssetAmount, "^\\d+(\\.\\d+)?$"))
	}
	if body.TakerAssetAmount != nil {
		if utf8.RuneCountInString(*body.TakerAssetAmount) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetAmount", *body.TakerAssetAmount, utf8.RuneCountInString(*body.TakerAssetAmount), 100, false))
		}
	}
	if body.MakerFee != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerFee", *body.MakerFee, "^\\d+(\\.\\d+)?$"))
	}
	if body.MakerFee != nil {
		if utf8.RuneCountInString(*body.MakerFee) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerFee", *body.MakerFee, utf8.RuneCountInString(*body.MakerFee), 100, false))
		}
	}
	if body.TakerFee != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerFee", *body.TakerFee, "^\\d+(\\.\\d+)?$"))
	}
	if body.TakerFee != nil {
		if utf8.RuneCountInString(*body.TakerFee) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerFee", *body.TakerFee, utf8.RuneCountInString(*body.TakerFee), 100, false))
		}
	}
	if body.ExpirationTimeSeconds != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, "^\\d+(\\.\\d+)?$"))
	}
	if body.ExpirationTimeSeconds != nil {
		if utf8.RuneCountInString(*body.ExpirationTimeSeconds) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.expirationTimeSeconds", *body.ExpirationTimeSeconds, utf8.RuneCountInString(*body.ExpirationTimeSeconds), 100, false))
		}
	}
	if body.Salt != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.salt", *body.Salt, "^\\d+(\\.\\d+)?$"))
	}
	if body.Salt != nil {
		if utf8.RuneCountInString(*body.Salt) > 100 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.salt", *body.Salt, utf8.RuneCountInString(*body.Salt), 100, false))
		}
	}
	if body.MakerAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerAssetData", *body.MakerAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.MakerAssetData != nil {
		if utf8.RuneCountInString(*body.MakerAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetData", *body.MakerAssetData, utf8.RuneCountInString(*body.MakerAssetData), 74, true))
		}
	}
	if body.MakerAssetData != nil {
		if utf8.RuneCountInString(*body.MakerAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerAssetData", *body.MakerAssetData, utf8.RuneCountInString(*body.MakerAssetData), 74, false))
		}
	}
	if body.TakerAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerAssetData", *body.TakerAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.TakerAssetData != nil {
		if utf8.RuneCountInString(*body.TakerAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetData", *body.TakerAssetData, utf8.RuneCountInString(*body.TakerAssetData), 74, true))
		}
	}
	if body.TakerAssetData != nil {
		if utf8.RuneCountInString(*body.TakerAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerAssetData", *body.TakerAssetData, utf8.RuneCountInString(*body.TakerAssetData), 74, false))
		}
	}
	if body.MakerFeeAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.makerFeeAssetData", *body.MakerFeeAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.MakerFeeAssetData != nil {
		if utf8.RuneCountInString(*body.MakerFeeAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerFeeAssetData", *body.MakerFeeAssetData, utf8.RuneCountInString(*body.MakerFeeAssetData), 74, true))
		}
	}
	if body.MakerFeeAssetData != nil {
		if utf8.RuneCountInString(*body.MakerFeeAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.makerFeeAssetData", *body.MakerFeeAssetData, utf8.RuneCountInString(*body.MakerFeeAssetData), 74, false))
		}
	}
	if body.TakerFeeAssetData != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.takerFeeAssetData", *body.TakerFeeAssetData, "^0x[0-9a-fA-F]{72}$"))
	}
	if body.TakerFeeAssetData != nil {
		if utf8.RuneCountInString(*body.TakerFeeAssetData) < 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerFeeAssetData", *body.TakerFeeAssetData, utf8.RuneCountInString(*body.TakerFeeAssetData), 74, true))
		}
	}
	if body.TakerFeeAssetData != nil {
		if utf8.RuneCountInString(*body.TakerFeeAssetData) > 74 {
			err = goa.MergeErrors(err, goa.InvalidLengthError("body.takerFeeAssetData", *body.TakerFeeAssetData, utf8.RuneCountInString(*body.TakerFeeAssetData), 74, false))
		}
	}
	if body.Signature != nil {
		err = goa.MergeErrors(err, goa.ValidatePattern("body.signature", *body.Signature, "^0x(([0-9a-fA-F][0-9a-fA-F])+)?$"))
	}
	return
}
